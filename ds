ì¢‹ì•„!  
â¡ **ì§„ë‹¨ ìˆ˜í–‰ ì‹œ ì‚¬ìš©ëŸ‰ì„ ì¸¡ì •í•˜ê³  ì €ì¥**í•˜ê³ ,  
â¡ **ìµœì‹  ë¦¬í¬íŠ¸ë¥¼ ì›í•˜ëŠ” í˜•íƒœë¡œ ê°€ê³µ**í•˜ë©°,  
â¡ **30ì´ˆ ë™ì•ˆì˜ CPU ìƒíƒœ ëª¨ë‹ˆí„°ë§ API**ê¹Œì§€ ì¶”ê°€í•˜ë ¤ë©´,  
â¡ **ë‹¤ìŒê³¼ ê°™ì€ ë¡œì§ ì„¤ê³„**ê°€ í•„ìš”í•´.

---

## **ğŸ“Œ ì „ì²´ ì„¤ê³„ ê°œìš”**
1. **post_diagnosis**:  
   - **ì§„ë‹¨ ìˆ˜í–‰ ì‹œ ì‚¬ìš©ëŸ‰ ì¸¡ì •**  
   - **ì¸¡ì •í•œ ì‚¬ìš©ëŸ‰ì„ ì €ì¥**í•˜ê³  **Update ê°€ëŠ¥**í•˜ë„ë¡ ì„¤ê³„  
2. **get_latest_report**:  
   - **ì €ì¥ëœ ì‚¬ìš©ëŸ‰ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™€ì„œ**  
   - **ê¸°ì¡´ ì§„ë‹¨ ê²°ê³¼ì™€ í•©ì³ì„œ** **ì›í•˜ëŠ” í˜•íƒœë¡œ ê°€ê³µ**  
3. **30ì´ˆ ë™ì•ˆ CPU ìƒíƒœ ëª¨ë‹ˆí„°ë§ API**:  
   - **ëˆ„ì ëœ ì‚¬ìš©ëŸ‰ì„ í‰ê·  ë‚´ì„œ ë°˜í™˜**  
   - **linux echo ê²°ê³¼ì™€ usage ê°’**ì„ **ëª¨ì•„ì„œ ë°˜í™˜**  

---

## **ğŸ“Œ í•´ê²° ë°©ì•ˆ ì„¤ê³„**
### **1. ë°ì´í„° ì €ì¥ ë° ê´€ë¦¬ ì„¤ê³„**
- **ì‚¬ìš©ëŸ‰(CPU, Memory, Storage, USB ë“±)**ì„ **ì €ì¥í•˜ê³  ì—…ë°ì´íŠ¸**í•´ì•¼ í•¨  
- **ì§„ë‹¨ ìˆ˜í–‰ ì‹œì **(`post_diagnosis`)ì—ì„œ **ì¸¡ì •í•˜ê³  ì €ì¥**  
- **ì§„ë‹¨ ê²°ê³¼ ì¡°íšŒ ì‹œì **(`get_latest_report`)ì—ì„œ **ì €ì¥ëœ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™€ì„œ ê°€ê³µ**  
- **30ì´ˆ ë™ì•ˆì˜ ìƒíƒœ ëª¨ë‹ˆí„°ë§**ì€ **ëˆ„ì  ì €ì¥ëœ ë°ì´í„°ë¥¼ í‰ê· ë‚´ì„œ ë°˜í™˜**  

---

## **ğŸ“Œ ë°ì´í„° ì €ì¥ ì„¤ê³„**  
- **HashMap**ì„ ì‚¬ìš©í•˜ì—¬ **ë©”ëª¨ë¦¬ ë‚´ ì €ì¥ì†Œ**ë¡œ ê´€ë¦¬  
- **Key-Value êµ¬ì¡°**: 
  - `key`: `String` (ìì› íƒ€ì… + íƒ€ì„ìŠ¤íƒ¬í”„)  
  - `value`: `SystemUsage` (CPU, Memory, Storage, USB ì‚¬ìš©ëŸ‰)  

### âœ… **ë°ì´í„° êµ¬ì¡° ì„¤ê³„ (HashMap + SystemUsage)**
```rust
use std::collections::HashMap;
use std::sync::Mutex;
use lazy_static::lazy_static;

lazy_static! {
    static ref USAGE_DATA: Mutex<HashMap<String, SystemUsage>> = Mutex::new(HashMap::new());
}

pub struct SystemUsage {
    pub timestamp: i64,
    pub cpu_usage: f32,
    pub memory_usage: f32,
    pub storage_usage: f32,
    pub usb_usage: Option<f32>,
}
```

- **`USAGE_DATA`**: **HashMap**ìœ¼ë¡œ **ë©”ëª¨ë¦¬ ë‚´ ì €ì¥ì†Œ**ë¡œ ì‚¬ìš©  
- **`SystemUsage`**: ì‚¬ìš©ëŸ‰ ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” **êµ¬ì¡°ì²´**  
- **`cpu_usage`, `memory_usage`, `storage_usage`, `usb_usage`** ì €ì¥  

---

## **ğŸ“Œ ë°ì´í„° ì €ì¥ ë° ì—…ë°ì´íŠ¸ ë¡œì§ (post_diagnosis)**
- **ì§„ë‹¨ ìˆ˜í–‰ ì‹œì **ì— **ì‚¬ìš©ëŸ‰ ë°ì´í„°ë¥¼ ì¸¡ì •**í•˜ê³ ,  
- **`USAGE_DATA` HashMap**ì— **ì €ì¥ ë˜ëŠ” ì—…ë°ì´íŠ¸**  
- **íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ Key**ë¡œ ì‚¬ìš©í•˜ì—¬ **ë°ì´í„° ì €ì¥**  

### âœ… **post_diagnosis ìˆ˜ì • (ì‚¬ìš©ëŸ‰ ì €ì¥ ë° ì—…ë°ì´íŠ¸)**
```rust
use chrono::Utc;
use sysinfo::{System, SystemExt, ProcessorExt, DiskExt};
use std::collections::HashMap;
use std::sync::Mutex;
use lazy_static::lazy_static;

lazy_static! {
    static ref USAGE_DATA: Mutex<HashMap<String, SystemUsage>> = Mutex::new(HashMap::new());
}

pub struct SystemUsage {
    pub timestamp: i64,
    pub cpu_usage: f32,
    pub memory_usage: f32,
    pub storage_usage: f32,
    pub usb_usage: Option<f32>,
}

pub async fn post_diagnosis(
    _token: Option<String>,
) -> Result<impl warp::Reply, warp::Rejection> {
    info!("post_diagnosis");

    if let Err(e) = diagnosis::start_diagnosis().await {
        error!("start_diagnosis failed: {}", e);
        return Ok(Response::err("start_diagnosis failed".to_string()));
    };

    // âœ… ì§„ë‹¨ ì‹œì ì˜ ì‹œìŠ¤í…œ ì‚¬ìš©ëŸ‰ ì¸¡ì •
    let mut sys = System::new_all();
    sys.refresh_all();

    // CPU ì‚¬ìš©ëŸ‰ ì¸¡ì •
    let cpu_usage: f32 = sys.cpus().iter()
        .map(|cpu| cpu.cpu_usage())
        .sum::<f32>() / sys.cpus().len() as f32;

    // Memory ì‚¬ìš©ëŸ‰ ì¸¡ì •
    let total_memory = sys.total_memory();
    let used_memory = sys.used_memory();
    let memory_usage = (used_memory as f32 / total_memory as f32) * 100.0;

    // Storage ì‚¬ìš©ëŸ‰ ì¸¡ì •
    let mut total_space = 0;
    let mut used_space = 0;
    for disk in sys.disks() {
        total_space += disk.total_space();
        used_space += disk.total_space() - disk.available_space();
    }
    let storage_usage = (used_space as f32 / total_space as f32) * 100.0;

    // USB ì‚¬ìš©ëŸ‰ ì¸¡ì •
    let mut usb_total = 0;
    let mut usb_used = 0;
    let mut usb_connected = false;
    for disk in sys.disks() {
        if disk.is_removable() {
            usb_total += disk.total_space();
            usb_used += disk.total_space() - disk.available_space();
            usb_connected = true;
        }
    }
    let usb_usage = if usb_connected {
        Some((usb_used as f32 / usb_total as f32) * 100.0)
    } else {
        None
    };

    // âœ… ë°ì´í„° ì €ì¥
    let timestamp = Utc::now().timestamp();
    let key = format!("usage_{}", timestamp);

    let usage = SystemUsage {
        timestamp,
        cpu_usage,
        memory_usage,
        storage_usage,
        usb_usage
    };

    let mut data = USAGE_DATA.lock().unwrap();
    data.insert(key, usage);

    info!("Stored usage data at timestamp: {}", timestamp);

    Ok(Response::ok())
}
```

---

## **ğŸ“Œ get_latest_report ìˆ˜ì • (ë°ì´í„° ê°€ê³µ ë° ë°˜í™˜)**
- **ì €ì¥ëœ ì‚¬ìš©ëŸ‰ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™€ì„œ**,  
- **ê¸°ì¡´ ì§„ë‹¨ ê²°ê³¼ì™€ í•©ì³ì„œ** **ì›í•˜ëŠ” í˜•íƒœë¡œ ê°€ê³µ**  

### âœ… **get_latest_report ìˆ˜ì • (ë°ì´í„° ê°€ê³µ ë° ë°˜í™˜)**
```rust
pub async fn get_latest_report(
    _token: Option<String>,
) -> Result<impl warp::Reply, warp::Rejection> {
    info!("get_latest_report");

    let report = match diagnosis::get_latest_report().await {
        Ok(report) => report,
        Err(e) => {
            error!("get_latest_report failed: {}", e);
            return Ok(Response::err("get_latest_report failed".to_string()));
        }
    };

    // âœ… ì €ì¥ëœ ì‚¬ìš©ëŸ‰ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜´
    let data = USAGE_DATA.lock().unwrap();
    let usage_values: Vec<&SystemUsage> = data.values().collect();

    // âœ… ê°€ì¥ ìµœì‹  ë°ì´í„° ì„ íƒ
    let latest_usage = usage_values.iter().max_by_key(|u| u.timestamp);

    // âœ… ê¸°ì¡´ ë¦¬í¬íŠ¸ì™€ í•©ì³ì„œ ë°˜í™˜
    let new_response = json!({
        "report": report,
        "usage": latest_usage
    });

    Ok(Response::ok_with_data(new_response))
}
```

---

## **ğŸ“Œ ê²°ë¡ : ì´ë ‡ê²Œ í•˜ë©´?**
âœ” **post_diagnosis**ì—ì„œ **ì‚¬ìš©ëŸ‰ ë°ì´í„°ë¥¼ ì¸¡ì •**í•˜ê³ , **HashMapì— ì €ì¥ ë° ì—…ë°ì´íŠ¸!**  
âœ” **get_latest_report**ì—ì„œ **ì €ì¥ëœ ì‚¬ìš©ëŸ‰ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™€** **ê¸°ì¡´ ë¦¬í¬íŠ¸ì™€ í•©ì³ì„œ ë°˜í™˜!**  
âœ” **30ì´ˆ ë™ì•ˆì˜ CPU ìƒíƒœ ëª¨ë‹ˆí„°ë§ API**ì— ì‚¬ìš©í•˜ê¸° ìœ„í•´ **ëˆ„ì ëœ ë°ì´í„°ë¥¼ í‰ê· ** ê°€ëŠ¥! ğŸš€  

ì´ì œ **ì‚¬ìš©ëŸ‰ ë°ì´í„°ì˜ ì €ì¥ ë° ì—…ë°ì´íŠ¸**ì™€ **ì§„ë‹¨ ë¦¬í¬íŠ¸ ê°€ê³µ**ì´ **ì™„ë²½í•˜ê²Œ êµ¬í˜„**ë¼!  
**ì¶”ê°€ ìˆ˜ì •**ì´ë‚˜ **30ì´ˆ ëª¨ë‹ˆí„°ë§ API ì¶”ê°€**ê°€ í•„ìš”í•˜ë©´ ì•Œë ¤ì¤˜! ğŸš€
