dashboard/implement.rs ì½”ë“œ ì´ë ‡ê²Œ í•˜ëŠ”ê±° ë§ì•„? ì—„ì²­ ì˜¤ë¥˜ ëœ¨ëŠ”ë°? ìˆ˜ì • ì œëŒ€ë¡œ í•´. ê·¸ë¦¬ê³  filters/diagnosis.rs í•¨ìˆ˜ì—ì„œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ë„ ì•Œë ¤ì¤˜

use std::sync::Arc;
use std::collections::VecDeque;
use chrono::Utc;
use platform_ipc_helper::blocking::data_manager;
use platform_common_types::core::{facility::signals::CniUpdated, FacilityType};
use log::{error, warn, info, debug};
use tokio::sync::Mutex;
use crate::utils::diagnosis::{Usage, get_current_timestamp, StorageInfo, UsbInfo, CpuUsageRecord};
#[derive(Debug, Default)]
pub struct DiagnosisImpl {
   resource_usage_history: Arc<Mutex<ResourceUsageHistory>>,
   cpu_usage_history: Arc<Mutex<VecDeque<CpuUsageRecord>>>,
}
#[derive(Debug, Default)]
pub struct ResourceUsageHistory {
   pub timestamps: Vec<String>,
   pub cpu_values: Vec<f32>,
   pub ram_values: Vec<f32>,
   pub storage_values: Vec<f32>,
   pub usb_values: Vec<f32>,
   pub disk_total_space: u64,
   pub usb_total_space: u64,
   pub usb_connected: bool,
}
impl DiagnosisImpl {
   pub async fn new() -> Arc<Self> {
       let instance = Arc::new(DiagnosisImpl {
           resource_usage_history: Arc::new(Mutex::new(ResourceUsageHistory::default())),
           cpu_usage_history: Arc::new(Mutex::new(VecDeque::with_capacity(30))),
       });
       let instance_clone = instance.clone();
       tokio::spawn(async move {
           instance_clone.init_cni_values().await;
           instance_clone.register_cni_update_handler.await;
       });
       instance
   }
   pub async fn get_latest_usage(&self) -> Usage {
       let history = self.resource_usage_history.lock().await;
       Usage {
           timestamp: get_current_timestamp(),
           cpu_usage: *history.cpu_values.last().unwrap_or(&0.0),
           ram_usage: *history.ram_values.last().unwrap_or(&0.0),
           storage: StorageInfo::default(),
           usb: UsbInfo::default(),
       }
   }
   pub async fn get_cpu_usage_history(&self) -> Vec<CpuUsageRecord> {
       let cpu_usage_history = self.cpu_usage_history.lock().await;
       cpu_usage_history.iter().cloned().collect()
   }
   pub async fn update_usage_history(&self, cpu: Option<f32>, ram: Option<f32>, storage: Option<f32>, usb: Option<f32>) {
       let mut history = self.resource_usage_history.lock().await;
       let current_timestamp = Utc::now().timestamp() as u64;
       history.timestamps.push(current_timestamp.to_string());
       if let Some(cpu_value) = cpu {
           let mut cpu_history = self.cpu_usage_history.lock().await;
           if cpu_history.len() == 30 {
               cpu_history.pop_front();
           }
           cpu_history.push_back(CpuUsageRecord { timestamp: current_timestamp, usage: cpu_value });
           history.cpu_values.push(cpu_value);
       }
       if let Some(ram_value) = ram {
           history.ram_values.push(ram_value);
       }
       if let Some(storage_value) = storage {
           history.storage_values.push(storage_value);
       }
       if let Some(usb_value) = usb {
           history.usb_values.push(usb_value);
           history.usb_connected = usb_value > 0.0;
       }
   }
   async fn init_cni_values(&self) {
       info!("Initializing CNI values...");
       let system_facilities_result = data_manager::facility::get_list_by_type(&FacilityType::System).await;
       let system_facilities = match system_facilities_result {
           Ok(facilities) => facilities,
           Err(e) => {
               error!("Failed to get system facilities: {e}");
               return;
           }
       };
       let system_facility = system_facilities.iter().find(|facility| facility.name == "system");
       if let Some(facility) = system_facility {
           for (cni, value) in &facility.cnis {
               if let Some(usage_value) = value {
                   let usage = usage_value.parse::<f32>().unwrap_or(0.0);
                   match cni.as_str() {
                       "cpu_usage" => self.update_usage_history(Some(usage), None, None, None).await,
                       "ram_usage" => self.update_usage_history(None, Some(usage), None, None).await,
                       _ => warn!("Unknown CNI: {cni}"),
                   }
               }
           }
       }
   }

   async fn register_cni_update_handler(self: Arc<Self>) {
    info!("Registering CNI update handler...");
    let mut filter = data_manager::facility::watch::FacilityFilter::default();
    filter.facility_type = Some(FacilityType::System);
    let instance_clone = Arc::clone(&self);
    if let Err(e) = data_manager::facility::watch::cni_updated(filter, move |value| {
        let instance = Arc::clone(&instance_clone);
        // ğŸ”¹ ì½œë°± ë‚´ë¶€ì—ì„œ ë¹„ë™ê¸° ì‹¤í–‰ì„ ìœ„í•´ tokio::spawn ì‚¬ìš©
        tokio::spawn(async move {
            let cni_updated: CniUpdated = match serde_json::from_str(value) {
                Ok(cni) => cni,
                Err(e) => {
                    error!("Failed to parse CNI updated message: {e}");
                    return;
                }
            };
            let usage = match cni_updated.value.parse::<f32>() {
                Ok(usage) => usage,
                Err(e) => {
                    warn!("Failed to parse {} usage: {e:?}", cni_updated.cni);
                    return;
                }
            };
            info!("CNI updated: {} - {}", cni_updated.cni, usage);
            match cni_updated.cni.as_str() {
                "cpu_usage" => instance.update_usage_history(Some(usage), None, None, None).await,
                "ram_usage" => instance.update_usage_history(None, Some(usage), None, None).await,
                "disk_usage" => instance.update_usage_history(None, None, Some(usage), None).await,
                "usb_usage" => instance.update_usage_history(None, None, None, Some(usage)).await,
                _ => warn!("Unknown CNI: {}", cni_updated.cni),
            }
        });
    }) {
        error!("Failed to register CNI updated handler: {:?}", e);
    }
 }
}
