내가 참고한 부분의 코드는 이런식으로 별도의 tx,rx 이런거 없이 잘했는데 왜 나는 안되는거야? 나도 이 코드들을 최대한 참고해서 하면 tx, rx 안 써도 되는 거 아닌가? 

1. main 함수 부분
"
#[cfg(feature = "linux")]
use crate::dbus::DbusServerBuilder;
use crate::{basic_diagnosis::system, diagnosis_result::diagnosis_results, status::status};
use clap::Parser;
use log::*;
use platform_common_types::core::{facility::signals::CniUpdated, FacilityType};
use platform_ipc_helper::blocking::data_manager;
#[cfg(feature = "webos")]
use platform_ipc_helper::{get_ls_handle, set_application_name};
#[cfg(feature = "linux")]
use tokio::runtime::Runtime;

mod basic_diagnosis;
mod data_logging;
mod db;
#[cfg(feature = "linux")]
mod dbus;
mod diagnosis_actor;
mod diagnosis_result;
#[cfg(feature = "webos")]
mod luna_service;
mod register_app;
mod report;
mod status;

/// Diagnosis service
#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    /// Name of the person to greet
    #[arg(short, long, default_value = "/tmp")]
    logging_path: String,
}

fn main() {
    pretty_env_logger::init();

    let args = Args::parse();
    data_logging::set_logging_path(args.logging_path.as_str());

    #[cfg(feature = "webos")]
    {
        set_application_name("com.b2b.diagnosis.service");
    }

    if let Err(e) = db::init() {
        error!("Failed to initialize db: {e}");
        std::process::exit(1);
    }

    // 기본 진단 항목을 등록합니다.
    // (CPU, 메모리, 저장소, 네트워크)
    system().register().unwrap();

    // 진단이 종료되었음을 알리기 위한 채널을 설정합니다.
    let notify_handle = status().read().get_notify_sender();
    diagnosis_results().set_status_notifier(notify_handle);

    info!("Diagnosis service is starting");
    // let _dbus_server = DbusServerBuilder::default().build().unwrap();
    #[cfg(feature = "linux")]
    let _dbus_server = Runtime::new().unwrap().block_on(async {
        DbusServerBuilder.build().await.unwrap_or_else(|e| {
            error!("Failed to build DbusServer: {e}");
            std::process::exit(1)
        })
    });

    #[cfg(feature = "webos")]
    {
        let handle = get_ls_handle().unwrap();
        let luna_service = luna_service::LunaService::new(handle);
        luna_service.run_background().unwrap();
    }
    info!("Diagnosis service is ready");

    // cpu, usb, ram, disk 사용량을 읽어옵니다.

    // system type facility를 가져옵니다.
    
    let system_facilities_result = data_manager::facility::get_list_by_type(&FacilityType::System);

    //Vec<FacilityInfo> 에서 sytem id를 찾아서 system_facility에 저장합니다.
    // system list 에서 name이 system인걸 찾아서, facility_id를 가져옵니다.
    let system_facilities = match system_facilities_result {
        Ok(facilities) => facilities,
        Err(e) => {
            error!("Failed to get system facilities: {e}");
            std::process::exit(1);
        }
    };
    let system_facility = system_facilities.iter().find(|facility| facility.name == "system");
    

    // // 디버깅을 위해 각 facility 배열 및 id 출력
    info!("system_facility: {system_facility:?}");

    if let Some(facility) = system_facility {
        for (cni, value) in &facility.cnis {
            if let Some(usage_value) = value {
                let usage = match usage_value.parse::<f32>() {
                    Ok(usage) => usage,
                    Err(e) => {
                        warn!("parse {} usage failed: {e:?}", cni);
                        continue;
                    }
                };
    
                match cni.as_str() {
                    "cpu0_usage" => system().add_cpu_usage(0, usage),
                    "cpu1_usage" => system().add_cpu_usage(1, usage),
                    "cpu2_usage" => system().add_cpu_usage(2, usage),
                    "cpu3_usage" => system().add_cpu_usage(3, usage),
                    "ram_usage" => system().add_memory_usage(usage),
                    "disk_usage" => system().add_storage_usage(usage),
                    "usb_usage" => system().add_usb_usage(usage),
                    _ => info!("Unknown cni: {}", cni),
                }
            }
        }
    }

    // 변경 시 처리할 함수를 등록합니다.
    let mut filter = data_manager::facility::watch::FacilityFilter::default();
    filter.facility_type = Some(FacilityType::System);
    if let Err(e) = data_manager::facility::watch::cni_updated(filter, move |value| {
        let cni_updated: CniUpdated = match serde_json::from_str(value) {
            Ok(cni) => cni,
            Err(e) => {
                warn!("parse value updated failed: {e:?}");
                return;
            }
        };

        // cni_updated에서 value를 가져옵니다.
        let usage_value = cni_updated.value.clone(); // value 필드가 CniUpdated 구조체에 있어야 합니다.

        // usage_value를 f32로 파싱합니다.
        let usage = match usage_value.parse::<f32>() {
            Ok(usage) => usage,
            Err(e) => {
                warn!("parse {} usage failed: {e:?}", cni_updated.cni);
                return;
            }
        };
        // 디버깅용 cni_updated 출력
        info!("CNI updated: {cni_updated:?}");
        match cni_updated.cni.as_str() {
            "cpu0_usage" => {
                system().add_cpu_usage(0, usage);
            }
            "cpu1_usage" => {
                system().add_cpu_usage(1, usage);
            }
            "cpu2_usage" => {
                system().add_cpu_usage(2, usage);
            }
            "cpu3_usage" => {
                system().add_cpu_usage(3, usage);
            }
            "ram_usage" => {
                system().add_memory_usage(usage);
            }
            "disk_usage" => {
                system().add_storage_usage(usage);
            }
            "usb_usage" => {
                system().add_usb_usage(usage);
            }
            _ => {
                info!("Unknown cni: {}", cni_updated.cni);
                return;
            }
        }

        debug!("CNI updated: {cni_updated:?}");
    }) {
        error!("Failed to watch controlled point: {e}");
        std::process::exit(1);
    }

    std::thread::park();
}
2. 값 처리 부분
"

"use chrono::Local;
use log::*;
use parking_lot::RwLock;
use platform_ipc_helper::blocking::connection_manager;
use std::{
    collections::VecDeque,
    sync::{Arc, OnceLock},
};

use anyhow::Result;
use platform_common_types::diagnosis::{self, ReportApp, ReportItem, ReportPassFail, Severity};

use crate::register_app::registered_apps;

static SYSTEM: OnceLock<System> = OnceLock::new();

pub fn system() -> &'static System {
    SYSTEM.get_or_init(Default::default)
}

#[derive(Debug)]
pub struct System {
    max_system_usage_cnt: usize,

    // 최대 cpu 개수는 4개로 한다.
    cpu0_usage: Arc<RwLock<VecDeque<f32>>>,
    cpu1_usage: Arc<RwLock<VecDeque<f32>>>,
    cpu2_usage: Arc<RwLock<VecDeque<f32>>>,
    cpu3_usage: Arc<RwLock<VecDeque<f32>>>,

    memory_usage: Arc<RwLock<VecDeque<f32>>>,
    storage_usage: Arc<RwLock<VecDeque<f32>>>,
    usb_usage: Arc<RwLock<VecDeque<f32>>>,
}

impl Default for System {
    fn default() -> Self {
        Self::new()
    }
}

impl System {
    pub fn new() -> Self {
        Self {
            max_system_usage_cnt: 5,
            cpu0_usage: Arc::new(RwLock::new(VecDeque::with_capacity(5))),
            cpu1_usage: Arc::new(RwLock::new(VecDeque::with_capacity(5))),
            cpu2_usage: Arc::new(RwLock::new(VecDeque::with_capacity(5))),
            cpu3_usage: Arc::new(RwLock::new(VecDeque::with_capacity(5))),
            memory_usage: Arc::new(RwLock::new(VecDeque::with_capacity(5))),
            storage_usage: Arc::new(RwLock::new(VecDeque::with_capacity(5))),
            usb_usage: Arc::new(RwLock::new(VecDeque::with_capacity(5))),
        }
    }

    pub fn register(&self) -> Result<()> {
        let mut app = diagnosis::AppInfo {
            name: "system".to_string(),
            items: Vec::new(),
        };

        // CPU 5초 사용량 평균이 90% 이상이면 Fatal
        let cpu = diagnosis::ItemInfo {
            name: "cpu_usage_fatal".to_string(),
            severity: Severity::Fatal,
            expire_time: 5,
        };
        app.items.push(cpu);

        // CPU 5초 사용량 평균이 70% 이상이면 Major
        let cpu = diagnosis::ItemInfo {
            name: "cpu_usage_warning".to_string(),
            severity: Severity::Major,
            expire_time: 5,
        };
        app.items.push(cpu);

        // 메모리 사용량이 90% 이상이면 Fatal
        let memory = diagnosis::ItemInfo {
            name: "memory_usage_fatal".to_string(),
            severity: Severity::Fatal,
            expire_time: 5,
        };
        app.items.push(memory);

        // 메모리 사용량이 70% 이상이면 Major
        let memory = diagnosis::ItemInfo {
            name: "memory_usage_warning".to_string(),
            severity: Severity::Major,
            expire_time: 5,
        };
        app.items.push(memory);

        // 스토리지 사용량이 90% 이상이면 Fatal
        let storage = diagnosis::ItemInfo {
            name: "storage_usage_fatal".to_string(),
            severity: Severity::Fatal,
            expire_time: 5,
        };
        app.items.push(storage);

        // 스토리지 사용량이 70% 이상이면 Major
        let storage = diagnosis::ItemInfo {
            name: "storage_usage_warning".to_string(),
            severity: Severity::Major,
            expire_time: 5,
        };
        app.items.push(storage);

        // USB 사용량이 90% 이상이면 Fatal
        let usb = diagnosis::ItemInfo {
            name: "usb_usage_fatal".to_string(),
            severity: Severity::Fatal,
            expire_time: 5,
        };
        app.items.push(usb);

        // USB 사용량이 70% 이상이면 Major
        let usb = diagnosis::ItemInfo {
            name: "usb_usage_warning".to_string(),
            severity: Severity::Major,
            expire_time: 5,
        };
        app.items.push(usb);

        // 네트워크 연결 상태 확인
        let connection = diagnosis::ItemInfo {
            name: "connection".to_string(),
            severity: Severity::Major,
            expire_time: 5,
        };
        app.items.push(connection);

        registered_apps()
            .write()
            .insert(app.name.clone(), app.into());

        Ok(())
    }

    pub fn add_cpu_usage(&self, cpu_index: u32, usage: f32) {
        info!("Add cpu usage: {usage} index: {cpu_index}");
        let mut cpu_usage = match cpu_index {
            0 => self.cpu0_usage.write(),
            1 => self.cpu1_usage.write(),
            2 => self.cpu2_usage.write(),
            3 => self.cpu3_usage.write(),
            _ => {
                warn!("Invalid cpu index: {cpu_index}");
                return;
            }
        };

        if cpu_usage.len() == self.max_system_usage_cnt {
            cpu_usage.pop_front();
        }
        cpu_usage.push_back(usage);
    }

    pub fn add_memory_usage(&self, usage: f32) {
        let mut memory_usage = self.memory_usage.write();
        if memory_usage.len() == self.max_system_usage_cnt {
            memory_usage.pop_front();
        }
        memory_usage.push_back(usage);
    }

    pub fn add_storage_usage(&self, usage: f32) {
        let mut storage_usage = self.storage_usage.write();
        if storage_usage.len() == self.max_system_usage_cnt {
            storage_usage.pop_front();
        }
        storage_usage.push_back(usage);
    }

    pub fn add_usb_usage(&self, usage: f32) {
        let mut usb_usage = self.usb_usage.write();
        if usb_usage.len() == self.max_system_usage_cnt {
            usb_usage.pop_front();
        }
        usb_usage.push_back(usage);
    }

    pub fn get_report(&self) -> Result<ReportApp> {
        let mut report = ReportApp::new("system");

        self.diagnose_cpu(&mut report)?;
        self.diagnose_memory(&mut report)?;
        self.diagnose_storage(&mut report)?;
        self.diagnose_usb(&mut report)?;
        self.diagnose_network(&mut report)?;

        Ok(report)
    }

    pub fn diagnose_cpu(&self, app: &mut ReportApp) -> Result<()> {
        // cpu 사용량 평균을 구한다.
        let cpu_usage = self.cpu0_usage.read();
        let cpu_avg = cpu_usage.iter().sum::<f32>() / cpu_usage.len() as f32;
        // 각각을 출력한다. 디버깅용
        let len = cpu_usage.len();
        info!("cpu total idx {len}");
        for (i, usage) in cpu_usage.iter().enumerate() {
            info!("CPU usage{i}: {usage}");
        }
    
        info!("CPU avg: {cpu_avg}");

        let mut result = ReportPassFail::Pass;
        let mut comment = "".to_string();

        if cpu_avg >= 90.0 {
            result = ReportPassFail::Fail;
            comment = "CPU usage is too high".to_string();
        }
        let item = ReportItem {
            name: "cpu_usage_fatal".to_string(),
            result,
            comment,
            published_time: Local::now().timestamp(),
        };
        app.items.push(item);

        let mut result = ReportPassFail::Pass;
        let mut comment = "".to_string();
        if cpu_avg >= 70.0 {
            result = ReportPassFail::Fail;
            comment = "CPU usage is high".to_string();
        }
        let item = ReportItem {
            name: "cpu_usage_warning".to_string(),
            result,
            comment,
            published_time: Local::now().timestamp(),
        };
        app.items.push(item);

        Ok(())
    }

    pub fn diagnose_memory(&self, app: &mut ReportApp) -> Result<()> {
        // memory 사용량 평균을 구한다.
        let memory_usage = system().memory_usage.read();
        let memory_avg = memory_usage.iter().sum::<f32>() / memory_usage.len() as f32;

        let len = memory_usage.len();
        
        info!("Memory usage: {memory_avg}");

        let mut result = ReportPassFail::Pass;
        let mut comment = "".to_string();

        if memory_avg >= 90.0 {
            result = ReportPassFail::Fail;
            comment = "Memory usage is too high".to_string();
        }
        let item = ReportItem {
            name: "memory_usage_fatal".to_string(),
            result,
            comment,
            published_time: Local::now().timestamp(),
        };
        app.items.push(item);

        let mut result = ReportPassFail::Pass;
        let mut comment = "".to_string();

        if memory_avg >= 70.0 {
            result = ReportPassFail::Fail;
            comment = "Memory usage is high".to_string();
        }
        let item = ReportItem {
            name: "memory_usage_warning".to_string(),
            result,
            comment,
            published_time: Local::now().timestamp(),
        };
        app.items.push(item);

        Ok(())
    }

    pub fn diagnose_usb(&self, app: &mut ReportApp) -> Result<()> {
        //usb 사용량을 구한다.
        let usb_usage = system().usb_usage.read();
        let usb_avg = usb_usage.iter().sum::<f32>() / usb_usage.len() as f32;

        info!("USB usage: {usb_avg}");

        let mut result = ReportPassFail::Pass;
        let mut comment = "".to_string();

        if usb_avg >= 90.0 {
            result = ReportPassFail::Fail;
            comment = "USB usage is too high".to_string();
        }

        let item = ReportItem {
            name: "usb_usage_fatal".to_string(),
            result,
            comment,
            published_time: Local::now().timestamp(),
        };
        app.items.push(item);

        let mut result = ReportPassFail::Pass;
        let mut comment = "".to_string();

        if usb_avg >= 70.0 {
            result = ReportPassFail::Fail;
            comment = "USB usage is high".to_string();
        }
        let item = ReportItem {
            name: "usb_usage_warning".to_string(),
            result,
            comment,
            published_time: Local::now().timestamp(),
        };
        app.items.push(item);
        
        Ok(())
    }

    pub fn diagnose_storage(&self, app: &mut ReportApp) -> Result<()> {
        // storage 사용량 평균을 구한다.
        let storage_usage = system().storage_usage.read();
        let storage_avg = storage_usage.iter().sum::<f32>() / storage_usage.len() as f32;

        info!("Storage usage: {storage_avg}");

        let mut result = ReportPassFail::Pass;
        let mut comment = "".to_string();

        if storage_avg >= 90.0 {
            result = ReportPassFail::Fail;
            comment = "Storage usage is too high".to_string();
        }
        let item = ReportItem {
            name: "storage_usage_fatal".to_string(),
            result,
            comment,
            published_time: Local::now().timestamp(),
        };
        app.items.push(item);

        let mut result = ReportPassFail::Pass;
        let mut comment = "".to_string();

        if storage_avg >= 70.0 {
            result = ReportPassFail::Fail;
            comment = "Storage usage is high".to_string();
        }
        let item = ReportItem {
            name: "storage_usage_warning".to_string(),
            result,
            comment,
            published_time: Local::now().timestamp(),
        };
        app.items.push(item);

        Ok(())
    }

    pub fn diagnose_network(&self, app: &mut ReportApp) -> Result<()> {
        let mut comment = String::new();

        // ifconfig 명령어를 실행하여 이더넷 인터페이스의 상태를 확인한다.
        // 이더넷 인터페이스가 없으면 Fatal로 처리한다.
        let network_status = match connection_manager::get_status() {
            Ok(_) => true,
            Err(e) => {
                warn!("Failed to get network status: {e}");
                comment = format!("Failed to get network status: {e}");
                false
            }
        };

        let item = ReportItem {
            name: "connection".to_string(),
            result: if network_status {
                ReportPassFail::Pass
            } else {
                ReportPassFail::Fail
            },
            comment,
            published_time: Local::now().timestamp(),
        };
        info!("Network connection: {network_status}");
        app.items.push(item);

        Ok(())
    }

    // pub fn diagnose_wifi() -> Result<()> {
    //     println!("Diagnosing wifi...");
    //     Ok(())
    // }
    //
    // pub fn diagnose_bluetooth() -> Result<()> {
    //     println!("Diagnosing bluetooth...");
    //     Ok(())
    // }
    //
    // pub fn diagnose_usb() -> Result<()> {
    //     println!("Diagnosing usb...");
    //     Ok(())
    // }
}
"
