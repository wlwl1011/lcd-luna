//utils/diagnosis/implement.rs
use std::sync::Arc;
use std::collections::VecDeque;
use platform_ipc_helper::blocking::data_manager; // 데이터 매니저를 사용하기 위해 추가
use platform_common_types::core::{facility::signals::CniUpdated, FacilityType};
use crate::utils::diagnosis::{Usage, get_current_timestamp, StorageInfo,UsbInfo,CpuUsageRecord};
use tokio::sync::Mutex; // tokio의 비동기 Mutex 사용
use anyhow::Result;
use log::{error, warn, info, debug};

#[derive(Debug, Default, Clone)]
pub struct DiagnosisImpl {
    resource_usage_history: Arc<Mutex<ResourceUsageHistory>>,
    cpu_usage_history: Arc<Mutex<VecDeque<CpuUsageRecord>>>,
 }

#[derive(Debug, Clone, Default)]
pub struct ResourceUsageHistory {
    pub timestamps: Vec<String>,
    pub cpu_values: Vec<f32>,
    pub ram_values: Vec<f32>,
    pub storage_values: Vec<f32>,
    pub usb_values: Vec<f32>,
    pub disk_total_space: u64,
    pub usb_total_space: u64,
    pub usb_connected: bool,
}

impl DiagnosisImpl {
    pub fn new() -> Self {
        let instance = DiagnosisImpl {
            resource_usage_history: Arc::new(Mutex::new(ResourceUsageHistory::default())),
            cpu_usage_history: Arc::new(Mutex::new(VecDeque::with_capacity(30))),
        };
        tokio::spawn(async {
            instance.init_cni_values().await;
            instance.register_cni_update_handler().await;
        });
        instance
    }

    // 1. 가장 최근 모니터링된 Usage 값을 반환하는 함수
    pub async fn get_latest_usage(&self) -> Result<Usage> {
        let history = self.resource_usage_history.lock().await;
        Ok(Usage {
            timestamp: get_current_timestamp(),
            cpu_usage: history.cpu_values.last().cloned().unwrap_or(0.0),
            ram_usage: history.ram_values.last().cloned().unwrap_or(0.0),
            storage: StorageInfo::default(),
            usb: UsbInfo::default(),
        })
    }

    // 2. CPU의 30초 동안의 변화 값을 반환하는 함수
    pub async fn get_cpu_usage_history(&self) -> Result<Vec<CpuUsageRecord>> {
        let cpu_usage_history = self.cpu_usage_history.lock().await;
        Ok(cpu_usage_history.iter().cloned().collect())
    }
    
   pub async fn update_usage_history(&self, cpu: Option<f32>, ram: Option<f32>, storage: Option<f32>, usb: Option<f32>) {
    let mut history = self.resource_usage_history.lock().await;
    let current_timestamp = chrono::Utc::now().timestamp() as u64;
    history.timestamps.push(current_timestamp.to_string());
    if let Some(cpu_value) = cpu {
        let mut cpu_history = self.cpu_usage_history.lock().await;
        if cpu_history.len() == 30 {
            cpu_history.pop_front();
        }
        cpu_history.push_back(CpuUsageRecord { timestamp: current_timestamp, usage: cpu_value });
        history.cpu_values.push(cpu_value);
    }
    if let Some(ram_value) = ram {
        history.ram_values.push(ram_value);
    }
    if let Some(storage_value) = storage {
        history.storage_values.push(storage_value);
    }
    if let Some(usb_value) = usb {
        history.usb_values.push(usb_value);
        history.usb_connected = usb_value > 0.0;
        }
    }



    async fn init_cni_values(&self) {
        info!("init_cni_values-----------------");
        // 초기값을 설정합니다.
        let system_facilities_result = data_manager::facility::get_list_by_type(&FacilityType::System);
    
        // Vec<FacilityInfo> 에서 system id를 찾아서 system_facility에 저장합니다.
        let system_facilities = match system_facilities_result {
            Ok(facilities) => facilities,
            Err(e) => {
                error!("Failed to get system facilities: {e}");
                std::process::exit(1);
            }
        };
    
        let system_facility = system_facilities.iter().find(|facility| facility.name == "system");
    
        // 디버깅을 위해 각 facility 배열 및 id 출력
        info!("system_facility: {system_facility:?}");
    
        if let Some(facility) = system_facility {
            for (cni, value) in &facility.cnis {
                if let Some(usage_value) = value {
                    let usage = match usage_value.parse::<f32>() {
                        Ok(usage) => usage,
                        Err(e) => {
                            warn!("parse {} usage failed: {e:?}", cni);
                            continue;
                        }
                    };
                    info!("cni: {cni}, usage: {usage}");
                    match cni.as_str() {
                        "cpu_usage" => {
                            // CPU 사용량 초기값 설정
                            self.update_usage_history(Some(usage), None, None, None);
                        }
                        "ram_usage" => {
                            // RAM 사용량 초기값 설정
                            self.update_usage_history(None, Some(usage), None, None);
                        }
                        "storage_usage" => {
                            // Storage 사용량 초기값 설정
                            self.update_usage_history(None, None, Some(usage), None);
                        }
                        "usb_usage" => {
                            // USB 사용량 초기값 설정
                            self.update_usage_history(None, None, None, Some(usage));
                        }
                        "usb_connected" => {
                            // USB 연결 상태 초기값 설정
                            self.update_usage_history(None, None, None, Some(usage));
                        }
                        "disk_total_space" => {
                            // 디스크 총 용량 초기값 설정
                            let mut history = self.resource_usage_history.lock().await; // await 추가
                            history.disk_total_space = usage as u64;
                        }
                        "usb_total_space" => {
                            // USB 총 용량 초기값 설정
                            let mut history = self.resource_usage_history.lock().await; // await 추가
                            history.usb_total_space = usage as u64;
                        }
                        _ => {
                            warn!("Unknown CNI: {cni}");
                        }
                    }
                }
            }
        }
    } 

    async fn register_cni_update_handler(&self) {
        // 변경 시 처리할 함수를 등록합니다.
        let mut filter = data_manager::facility::watch::FacilityFilter::default();
        filter.facility_type = Some(FacilityType::System);
    
        if let Err(e) = data_manager::facility::watch::cni_updated(filter, {
            let self_clone = self.clone();
            move |value| {
                let self_clone = self_clone.clone();
                let value_clone = value.to_string(); // value를 String으로 변환하여 소유권을 가져옵니다.
                tokio::spawn(async move {
                    let cni_updated: CniUpdated = match serde_json::from_str(&value_clone) {
                        Ok(cni) => cni,
                        Err(e) => {
                            eprintln!("Failed to parse CNI updated value: {:?}", e);
                            return;
                        }
                    };
    
                    // 디버깅용 cni_updated 출력
                    info!("CNI updated: {:?}", cni_updated);
    
                    // cni_updated에서 value를 가져옵니다.
                    let usage_value = cni_updated.value.clone(); // value 필드가 CniUpdated 구조체에 있어야 합니다.
    
                    // usage_value를 f32로 파싱합니다.
                    let usage = match usage_value.parse::<f32>() {
                        Ok(usage) => usage,
                        Err(e) => {
                            eprintln!("Failed to parse {} usage: {:?}", cni_updated.cni, e);
                            return;
                        }
                    };
    
                    match cni_updated.cni.as_str() {
                        "cpu_usage" => {
                            // CPU 사용량 업데이트
                            self_clone.update_usage_history(Some(usage), None, None, None).await;
                        }
                        "ram_usage" => {
                            // RAM 사용량 업데이트
                            self_clone.update_usage_history(None, Some(usage), None, None).await;
                        }
                        "storage_usage" => {
                            // Storage 사용량 업데이트
                            self_clone.update_usage_history(None, None, Some(usage), None).await;
                        }
                        "usb_usage" => {
                            // USB 사용량 업데이트
                            self_clone.update_usage_history(None, None, None, Some(usage)).await;
                        }
                        "usb_connected" => {
                            // USB 연결 상태 업데이트
                            self_clone.update_usage_history(None, None, None, Some(usage)).await;
                        }
                        "disk_total_space" => {
                            // 디스크 총 용량 업데이트
                            let mut history = self_clone.resource_usage_history.lock().await;
                            history.disk_total_space = usage as u64;
                        }
                        "usb_total_space" => {
                            // USB 총 용량 업데이트
                            let mut history = self_clone.resource_usage_history.lock().await;
                            history.usb_total_space = usage as u64;
                        }
                        _ => {
                            eprintln!("Unknown CNI: {}", cni_updated.cni);
                        }
                    }
                });
            }
        }) {
            eprintln!("Failed to register CNI updated handler: {:?}", e);
        }
    }

    
}
