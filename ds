좋아!  
➡ **진단 수행 시 사용량을 측정하고 저장**하고,  
➡ **최신 리포트를 원하는 형태로 가공**하며,  
➡ **30초 동안의 CPU 상태 모니터링 API**까지 추가하려면,  
➡ **다음과 같은 로직 설계**가 필요해.

---

## **📌 전체 설계 개요**
1. **post_diagnosis**:  
   - **진단 수행 시 사용량 측정**  
   - **측정한 사용량을 저장**하고 **Update 가능**하도록 설계  
2. **get_latest_report**:  
   - **저장된 사용량 데이터를 불러와서**  
   - **기존 진단 결과와 합쳐서** **원하는 형태로 가공**  
3. **30초 동안 CPU 상태 모니터링 API**:  
   - **누적된 사용량을 평균 내서 반환**  
   - **linux echo 결과와 usage 값**을 **모아서 반환**  

---

## **📌 해결 방안 설계**
### **1. 데이터 저장 및 관리 설계**
- **사용량(CPU, Memory, Storage, USB 등)**을 **저장하고 업데이트**해야 함  
- **진단 수행 시점**(`post_diagnosis`)에서 **측정하고 저장**  
- **진단 결과 조회 시점**(`get_latest_report`)에서 **저장된 데이터를 불러와서 가공**  
- **30초 동안의 상태 모니터링**은 **누적 저장된 데이터를 평균내서 반환**  

---

## **📌 데이터 저장 설계**  
- **HashMap**을 사용하여 **메모리 내 저장소**로 관리  
- **Key-Value 구조**: 
  - `key`: `String` (자원 타입 + 타임스탬프)  
  - `value`: `SystemUsage` (CPU, Memory, Storage, USB 사용량)  

### ✅ **데이터 구조 설계 (HashMap + SystemUsage)**
```rust
use std::collections::HashMap;
use std::sync::Mutex;
use lazy_static::lazy_static;

lazy_static! {
    static ref USAGE_DATA: Mutex<HashMap<String, SystemUsage>> = Mutex::new(HashMap::new());
}

pub struct SystemUsage {
    pub timestamp: i64,
    pub cpu_usage: f32,
    pub memory_usage: f32,
    pub storage_usage: f32,
    pub usb_usage: Option<f32>,
}
```

- **`USAGE_DATA`**: **HashMap**으로 **메모리 내 저장소**로 사용  
- **`SystemUsage`**: 사용량 데이터를 저장하는 **구조체**  
- **`cpu_usage`, `memory_usage`, `storage_usage`, `usb_usage`** 저장  

---

## **📌 데이터 저장 및 업데이트 로직 (post_diagnosis)**
- **진단 수행 시점**에 **사용량 데이터를 측정**하고,  
- **`USAGE_DATA` HashMap**에 **저장 또는 업데이트**  
- **타임스탬프를 Key**로 사용하여 **데이터 저장**  

### ✅ **post_diagnosis 수정 (사용량 저장 및 업데이트)**
```rust
use chrono::Utc;
use sysinfo::{System, SystemExt, ProcessorExt, DiskExt};
use std::collections::HashMap;
use std::sync::Mutex;
use lazy_static::lazy_static;

lazy_static! {
    static ref USAGE_DATA: Mutex<HashMap<String, SystemUsage>> = Mutex::new(HashMap::new());
}

pub struct SystemUsage {
    pub timestamp: i64,
    pub cpu_usage: f32,
    pub memory_usage: f32,
    pub storage_usage: f32,
    pub usb_usage: Option<f32>,
}

pub async fn post_diagnosis(
    _token: Option<String>,
) -> Result<impl warp::Reply, warp::Rejection> {
    info!("post_diagnosis");

    if let Err(e) = diagnosis::start_diagnosis().await {
        error!("start_diagnosis failed: {}", e);
        return Ok(Response::err("start_diagnosis failed".to_string()));
    };

    // ✅ 진단 시점의 시스템 사용량 측정
    let mut sys = System::new_all();
    sys.refresh_all();

    // CPU 사용량 측정
    let cpu_usage: f32 = sys.cpus().iter()
        .map(|cpu| cpu.cpu_usage())
        .sum::<f32>() / sys.cpus().len() as f32;

    // Memory 사용량 측정
    let total_memory = sys.total_memory();
    let used_memory = sys.used_memory();
    let memory_usage = (used_memory as f32 / total_memory as f32) * 100.0;

    // Storage 사용량 측정
    let mut total_space = 0;
    let mut used_space = 0;
    for disk in sys.disks() {
        total_space += disk.total_space();
        used_space += disk.total_space() - disk.available_space();
    }
    let storage_usage = (used_space as f32 / total_space as f32) * 100.0;

    // USB 사용량 측정
    let mut usb_total = 0;
    let mut usb_used = 0;
    let mut usb_connected = false;
    for disk in sys.disks() {
        if disk.is_removable() {
            usb_total += disk.total_space();
            usb_used += disk.total_space() - disk.available_space();
            usb_connected = true;
        }
    }
    let usb_usage = if usb_connected {
        Some((usb_used as f32 / usb_total as f32) * 100.0)
    } else {
        None
    };

    // ✅ 데이터 저장
    let timestamp = Utc::now().timestamp();
    let key = format!("usage_{}", timestamp);

    let usage = SystemUsage {
        timestamp,
        cpu_usage,
        memory_usage,
        storage_usage,
        usb_usage
    };

    let mut data = USAGE_DATA.lock().unwrap();
    data.insert(key, usage);

    info!("Stored usage data at timestamp: {}", timestamp);

    Ok(Response::ok())
}
```

---

## **📌 get_latest_report 수정 (데이터 가공 및 반환)**
- **저장된 사용량 데이터를 불러와서**,  
- **기존 진단 결과와 합쳐서** **원하는 형태로 가공**  

### ✅ **get_latest_report 수정 (데이터 가공 및 반환)**
```rust
pub async fn get_latest_report(
    _token: Option<String>,
) -> Result<impl warp::Reply, warp::Rejection> {
    info!("get_latest_report");

    let report = match diagnosis::get_latest_report().await {
        Ok(report) => report,
        Err(e) => {
            error!("get_latest_report failed: {}", e);
            return Ok(Response::err("get_latest_report failed".to_string()));
        }
    };

    // ✅ 저장된 사용량 데이터를 불러옴
    let data = USAGE_DATA.lock().unwrap();
    let usage_values: Vec<&SystemUsage> = data.values().collect();

    // ✅ 가장 최신 데이터 선택
    let latest_usage = usage_values.iter().max_by_key(|u| u.timestamp);

    // ✅ 기존 리포트와 합쳐서 반환
    let new_response = json!({
        "report": report,
        "usage": latest_usage
    });

    Ok(Response::ok_with_data(new_response))
}
```

---

## **📌 결론: 이렇게 하면?**
✔ **post_diagnosis**에서 **사용량 데이터를 측정**하고, **HashMap에 저장 및 업데이트!**  
✔ **get_latest_report**에서 **저장된 사용량 데이터를 불러와** **기존 리포트와 합쳐서 반환!**  
✔ **30초 동안의 CPU 상태 모니터링 API**에 사용하기 위해 **누적된 데이터를 평균** 가능! 🚀  

이제 **사용량 데이터의 저장 및 업데이트**와 **진단 리포트 가공**이 **완벽하게 구현**돼!  
**추가 수정**이나 **30초 모니터링 API 추가**가 필요하면 알려줘! 🚀
