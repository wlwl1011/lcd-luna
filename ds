//utils/diagnosis.rs
use tokio::sync::Mutex; // tokio의 비동기 Mutex 사용
use log::error;
use std::sync::OnceLock;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Usage {
    pub timestamp: String,
    pub cpu_usage: f32,
    pub ram_usage: f32,
    pub storage: StorageInfo,
    pub usb: UsbInfo,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct CpuUsageRecord {
    pub timestamp: u64,
    pub usage: f32,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct UsbInfo {
    pub connected: bool,
    pub total: Option<u64>,
    pub used: Option<u64>,
    pub usage: Option<f32>,
}

#[derive(Debug, Clone,Default,Serialize, Deserialize)]
pub struct StorageInfo {
    pub total: u64,
    pub used: u64,
    pub usage: f32,
}

pub fn get_current_timestamp() -> String {
    let now = chrono::Utc::now();
    now.to_rfc3339()
}

pub mod implement;
// DiagnosisInterface 타입 정의
pub type DiagnosisInterface = implement::DiagnosisImpl;

// 전역 인스턴스
static DIAGNOSIS_INSTANCE: OnceLock<Mutex<DiagnosisInterface>> = OnceLock::new();

pub fn init_diagnosis_instance() {
    DIAGNOSIS_INSTANCE.get_or_init(Mutex::default);
}

pub fn diagnosis_instance() -> &'static Mutex<DiagnosisInterface> {
    match DIAGNOSIS_INSTANCE.get() {
        Some(c) => c,
        None => {
            error!("Failed to get diagnosis instance. exit.");
            std::process::exit(1);
        }
    }
}


//utils/diagnosis/implement.rs
use std::sync::Arc;
use std::collections::VecDeque;
use platform_ipc_helper::blocking::data_manager; // 데이터 매니저를 사용하기 위해 추가
use platform_common_types::core::{facility::signals::CniUpdated, FacilityType};
use platform_common_types::core::facility::FacilityInfo;
use crate::utils::diagnosis::{Usage, get_current_timestamp, StorageInfo,UsbInfo,CpuUsageRecord};
use tokio::sync::Mutex; // tokio의 비동기 Mutex 사용
use anyhow::Result;
use log::{error, warn, info, debug};

#[derive(Debug, Default, Clone)]
pub struct DiagnosisImpl {
    resource_usage_history: Arc<Mutex<ResourceUsageHistory>>, // 리소스 사용 기록
    cpu_usage_history: Arc<Mutex<VecDeque<CpuUsageRecord>>>, // CPU 사용량 기록
}

#[derive(Debug, Clone, Default)]
pub struct ResourceUsageHistory {
    pub timestamps: Vec<String>,
    pub cpu_values: Vec<f32>,
    pub ram_values: Vec<f32>,
    pub storage_values: Vec<f32>,
    pub usb_values: Vec<f32>,
    pub disk_total_space: u64,
    pub usb_total_space: u64,
    pub usb_connected: bool,
}

impl DiagnosisImpl {
    pub async fn new() -> Self {
        let instance = DiagnosisImpl {
            resource_usage_history: Arc::new(Mutex::new(ResourceUsageHistory::default())),
            cpu_usage_history: Arc::new(Mutex::new(VecDeque::with_capacity(30))), // 30초 동안의 CPU 사용량을 저장
        };

        instance.init_cni_values().await;
        instance.register_cni_update_handler().await;
        instance
    }

    // 1. 가장 최근 모니터링된 Usage 값을 반환하는 함수
    pub async fn get_latest_usage(&self) -> Result<Usage> {
        let history: tokio::sync::MutexGuard<'_, ResourceUsageHistory> = self.resource_usage_history.lock().await;

        let latest_cpu_usage = history.cpu_values.last().cloned().unwrap_or(0.0);
        let latest_ram_usage = history.ram_values.last().cloned().unwrap_or(0.0);
        let usb_connected = history.usb_connected;

        let usage = Usage {
            timestamp: get_current_timestamp(),
            cpu_usage: latest_cpu_usage,
            ram_usage: latest_ram_usage,
            storage: StorageInfo::default(), // StorageInfo는 적절히 정의되어야 합니다.
            usb: UsbInfo::default(), // UsbInfo는 적절히 정의되어야 합니다.
        };

        Ok(usage)
    }

    // 2. CPU의 30초 동안의 변화 값을 반환하는 함수
    pub async fn get_cpu_usage_history(&self) -> Result<Vec<CpuUsageRecord>> {
        let cpu_usage_history = self.cpu_usage_history.lock().await;
        Ok(cpu_usage_history.iter().cloned().collect())
    }

    pub async fn update_usage_history(&self, cpu: Option<f32>, ram: Option<f32>, storage: Option<f32>, usb: Option<f32>) {
        let mut history = self.resource_usage_history.lock().await;

        // 현재 타임스탬프를 기록
        let current_timestamp = get_current_timestamp().parse::<u64>().unwrap_or(0);
        history.timestamps.push(current_timestamp.to_string());

        // CPU 사용량 업데이트
        if let Some(cpu_value) = cpu {
            let mut cpu_history = self.cpu_usage_history.lock().await;
            if cpu_history.len() == 30 {
                cpu_history.pop_front(); // 30초가 넘으면 가장 오래된 값을 제거
            }
            cpu_history.push_back(CpuUsageRecord { timestamp: current_timestamp, usage: cpu_value }); // 새로운 CPU 사용량 추가
            history.cpu_values.push(cpu_value); // 전체 기록에도 추가
        }

        // RAM, Storage, USB 사용량 업데이트
        if let Some(ram_value) = ram {
            history.ram_values.push(ram_value);
        }
        if let Some(storage_value) = storage {
            history.storage_values.push(storage_value);
        }
        if let Some(usb_value) = usb {
            history.usb_values.push(usb_value);
            history.usb_connected = usb_value > 0.0; // USB 연결 상태 업데이트
        }
    }

    async fn init_cni_values(&self) {
        info!("init_cni_values-----------------");
        // 초기값을 설정합니다.
        let system_facilities_result = data_manager::facility::get_list_by_type(&FacilityType::System);
    
        // Vec<FacilityInfo> 에서 system id를 찾아서 system_facility에 저장합니다.
        let system_facilities = match system_facilities_result {
            Ok(facilities) => facilities,
            Err(e) => {
                error!("Failed to get system facilities: {e}");
                std::process::exit(1);
            }
        };
    
        let system_facility = system_facilities.iter().find(|facility| facility.name == "system");
    
        // 디버깅을 위해 각 facility 배열 및 id 출력
        info!("system_facility: {system_facility:?}");
    
        if let Some(facility) = system_facility {
            for (cni, value) in &facility.cnis {
                if let Some(usage_value) = value {
                    let usage = match usage_value.parse::<f32>() {
                        Ok(usage) => usage,
                        Err(e) => {
                            warn!("parse {} usage failed: {e:?}", cni);
                            continue;
                        }
                    };
                    info!("cni: {cni}, usage: {usage}");
                    match cni.as_str() {
                        "cpu_usage" => {
                            // CPU 사용량 초기값 설정
                            self.update_usage_history(Some(usage), None, None, None);
                        }
                        "ram_usage" => {
                            // RAM 사용량 초기값 설정
                            self.update_usage_history(None, Some(usage), None, None);
                        }
                        "storage_usage" => {
                            // Storage 사용량 초기값 설정
                            self.update_usage_history(None, None, Some(usage), None);
                        }
                        "usb_usage" => {
                            // USB 사용량 초기값 설정
                            self.update_usage_history(None, None, None, Some(usage));
                        }
                        "usb_connected" => {
                            // USB 연결 상태 초기값 설정
                            self.update_usage_history(None, None, None, Some(usage));
                        }
                        "disk_total_space" => {
                            // 디스크 총 용량 초기값 설정
                            let mut history = self.resource_usage_history.lock().await; // await 추가
                            history.disk_total_space = usage as u64;
                        }
                        "usb_total_space" => {
                            // USB 총 용량 초기값 설정
                            let mut history = self.resource_usage_history.lock().await; // await 추가
                            history.usb_total_space = usage as u64;
                        }
                        _ => {
                            warn!("Unknown CNI: {cni}");
                        }
                    }
                }
            }
        }
    } 

    async fn register_cni_update_handler(&self) {
        // 변경 시 처리할 함수를 등록합니다.
        let mut filter = data_manager::facility::watch::FacilityFilter::default();
        filter.facility_type = Some(FacilityType::System);
    
        if let Err(e) = data_manager::facility::watch::cni_updated(filter, {
            let self_clone = self.clone();
            move |value| {
                let self_clone = self_clone.clone();
                let value_clone = value.to_string(); // value를 String으로 변환하여 소유권을 가져옵니다.
                tokio::spawn(async move {
                    let cni_updated: CniUpdated = match serde_json::from_str(&value_clone) {
                        Ok(cni) => cni,
                        Err(e) => {
                            eprintln!("Failed to parse CNI updated value: {:?}", e);
                            return;
                        }
                    };
    
                    // 디버깅용 cni_updated 출력
                    info!("CNI updated: {:?}", cni_updated);
    
                    // cni_updated에서 value를 가져옵니다.
                    let usage_value = cni_updated.value.clone(); // value 필드가 CniUpdated 구조체에 있어야 합니다.
    
                    // usage_value를 f32로 파싱합니다.
                    let usage = match usage_value.parse::<f32>() {
                        Ok(usage) => usage,
                        Err(e) => {
                            eprintln!("Failed to parse {} usage: {:?}", cni_updated.cni, e);
                            return;
                        }
                    };
    
                    match cni_updated.cni.as_str() {
                        "cpu_usage" => {
                            // CPU 사용량 업데이트
                            self_clone.update_usage_history(Some(usage), None, None, None).await;
                        }
                        "ram_usage" => {
                            // RAM 사용량 업데이트
                            self_clone.update_usage_history(None, Some(usage), None, None).await;
                        }
                        "storage_usage" => {
                            // Storage 사용량 업데이트
                            self_clone.update_usage_history(None, None, Some(usage), None).await;
                        }
                        "usb_usage" => {
                            // USB 사용량 업데이트
                            self_clone.update_usage_history(None, None, None, Some(usage)).await;
                        }
                        "usb_connected" => {
                            // USB 연결 상태 업데이트
                            self_clone.update_usage_history(None, None, None, Some(usage)).await;
                        }
                        "disk_total_space" => {
                            // 디스크 총 용량 업데이트
                            let mut history = self_clone.resource_usage_history.lock().await;
                            history.disk_total_space = usage as u64;
                        }
                        "usb_total_space" => {
                            // USB 총 용량 업데이트
                            let mut history = self_clone.resource_usage_history.lock().await;
                            history.usb_total_space = usage as u64;
                        }
                        _ => {
                            eprintln!("Unknown CNI: {}", cni_updated.cni);
                        }
                    }
                });
            }
        }) {
            eprintln!("Failed to register CNI updated handler: {:?}", e);
        }
    }

    
}

use warp::Filter;

use super::ACP_HEADER_TOKEN;

/// 등록된 앱들을 조회
pub(crate) fn get_list(
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::path!("diagnosis")
        .and(warp::get())
        .and(warp::header::optional::<String>(ACP_HEADER_TOKEN))
        .and_then(inner::get_list)
}

/// 진단 수행
pub(crate) fn post_diagnosis(
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::path!("diagnosis")
        .and(warp::post())
        .and(warp::header::optional::<String>(ACP_HEADER_TOKEN))
        .and_then(inner::post_diagnosis)
}

/// 진단 중지
pub(crate) fn post_stop_diagnosis(
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::path!("diagnosis" / "stop")
        .and(warp::post())
        .and(warp::header::optional::<String>(ACP_HEADER_TOKEN))
        .and_then(inner::post_stop_diagnosis)
}

// 진단 상태
pub(crate) fn get_status(
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::path!("diagnosis" / "status")
        .and(warp::get())
        .and(warp::header::optional::<String>(ACP_HEADER_TOKEN))
        .and_then(inner::get_status)
}


// 가장 최신 결과 리포트 조회
pub(crate) fn get_latest_report(
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::path!("diagnosis" / "report")
        .and(warp::get())
        .and(warp::header::optional::<String>(ACP_HEADER_TOKEN))
        .and_then(inner::get_latest_report)
}

// CPU 사용량 조회
pub(crate) fn get_cpu_usage(
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::path!("diagnosis" / "cpu")
        .and(warp::get())
        .and(warp::header::optional::<String>(ACP_HEADER_TOKEN))
        .and_then(inner::get_cpu_usage)
}

// 진단 결과 리포트 삭제
pub(crate) fn delete_reports(
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::path!("diagnosis" / "reports")
        .and(warp::delete())
        .and(warp::header::optional::<String>(ACP_HEADER_TOKEN))
        .and_then(inner::delete_reports)
}

mod inner {
    use crate::response::Response;
    use log::*;
    use platform_ipc_helper::sync::diagnosis;
    use serde_json::json;
    use warp::Rejection;

    use crate::utils::diagnosis::{diagnosis_instance, Usage, CpuUsageRecord};

    async fn get_diagnosis_impl() -> Result<Usage, Rejection> {
        let diagnosis = diagnosis_instance().lock().await; // MutexGuard를 얻습니다.
        diagnosis.get_latest_usage().await.map_err(|_| warp::reject()) // 오류를 warp::Rejection으로 변환
    }
    
    async fn get_diagnosis_impl_cpu() -> Result<Vec<CpuUsageRecord>, Rejection> {
        let diagnosis = diagnosis_instance().lock().await; // MutexGuard를 얻습니다.
        diagnosis.get_cpu_usage_history().await.map_err(|_| warp::reject()) // 오류를 warp::Rejection으로 변환
    }

    pub async fn get_list(_token: Option<String>) -> Result<impl warp::Reply, warp::Rejection> {
        // TODO 권한 추가
        // if !access_control().check_permission(token.as_deref(), Permission::) {
        //     return Ok(Response::err("Permission denied".to_string()));
        // }

        info!("get_app_list");

        let apps = match diagnosis::get_registered_apps().await {
            Ok(apps) => apps,
            Err(e) => {
                error!("get_registered_apps failed: {}", e);
                return Ok(Response::err("get_registered_apps failed".to_string()));
            }
        };

        Ok(Response::ok_with_data(json!(apps)))
    }

    pub async fn post_diagnosis(
        _token: Option<String>,
    ) -> Result<impl warp::Reply, warp::Rejection> {
        // TODO 권한 추가
        // if !access_control().check_permission(token.as_deref(), Permission::) {
        //     return Ok(Response::err("Permission denied".to_string()));
        // }

        info!("post_diagnosis");

        if let Err(e) = diagnosis::start_diagnosis().await {
            error!("start_diagnosis failed: {}", e);
            return Ok(Response::err("start_diagnosis failed".to_string()));
        };

        Ok(Response::ok())
    }

    pub async fn post_stop_diagnosis(
        _token: Option<String>,
    ) -> Result<impl warp::Reply, warp::Rejection> {
        // TODO 권한 추가
        // if !access_control().check_permission(token.as_deref(), Permission::) {
        //     return Ok(Response::err("Permission denied".to_string()));
        // }

        info!("post_stop_diagnosis");

        if let Err(e) = diagnosis::stop_diagnosis().await {
            error!("stop_diagnosis failed: {}", e);
            return Ok(Response::err("stop_diagnosis failed".to_string()));
        };

        Ok(Response::ok())
    }

    pub async fn get_status(_token: Option<String>) -> Result<impl warp::Reply, warp::Rejection> {
        // TODO 권한 추가
        // if !access_control().check_permission(token.as_deref(), Permission::) {
        //     return Ok(Response::err("Permission denied".to_string()));
        // }

        info!("get_status");

        let status = match diagnosis::get_diagnosis_status().await {
            Ok(status) => status,
            Err(e) => {
                error!("get_status failed: {}", e);
                return Ok(Response::err("get_status failed".to_string()));
            }
        };

        Ok(Response::ok_with_data(json!(status)))
    }


    pub async fn get_latest_report(
        _token: Option<String>,
    ) -> Result<impl warp::Reply, warp::Rejection> {
        // TODO 권한 추가
        // if !access_control().check_permission(token.as_deref(), Permission::) {
        //     return Ok(Response::err("Permission denied".to_string()));
        // }

        info!("get_latest_report");

        let report = match diagnosis::get_latest_report().await {
            Ok(report) => report,
            Err(e) => {
                error!("get_latest_report failed: {}", e);
                return Ok(Response::err("get_latest_report failed".to_string()));
            }
        };

        let usage = get_diagnosis_impl().await?; // await 사용
        info!("usage: {:?}", usage);


        // 추가로 실시간 system 사용량을 받아오는 함수를 호출하여 report에 추가 -> utils/diagnostics.rs에 있는 함수 사용

        Ok(Response::ok_with_data(json!(report)))
    }

    pub async fn get_cpu_usage(
        _token: Option<String>,
    ) -> Result<impl warp::Reply, warp::Rejection> {
        // TODO 권한 추가
        // if !access_control().check_permission(token.as_deref(), Permission::) {
        //     return Ok(Response::err("Permission denied".to_string()));
        // }

        let usage = get_diagnosis_impl_cpu().await?; // await 사용
        info!("usage: {:?}", usage);

        Ok(Response::ok_with_data(json!(usage)))
    }


    pub async fn delete_reports(
        _token: Option<String>,
    ) -> Result<impl warp::Reply, warp::Rejection> {
        // TODO 권한 추가
        // if !access_control().check_permission(token.as_deref(), Permission::) {
        //     return Ok(Response::err("Permission denied".to_string()));
        // }

        info!("delete_reports");

        if let Err(e) = diagnosis::clear_reports().await {
            error!("delete_reports failed: {}", e);
            return Ok(Response::err("delete_reports failed".to_string()));
        };

        Ok(Response::ok())
    }
}
