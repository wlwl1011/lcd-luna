" INFO  rest_server::utils::diagnosis::implement > Registering CNI update handler...                                                                                                     
 DEBUG moonlight::blocking                      > Received watch request to luna service                                                                                                
 DEBUG moonlight::sync                          > Spawning luna service thread                                                                                                          
thread '<unnamed>' panicked at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/glib-0.18.5/src/main_context_futures.rs:562:14:                                               
Spawning local futures only allowed on the thread owning the MainContext: BoolError { message: "Failed to acquire ownership of main context, already acquired by another thread", filen}
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace" 

실행시키면 다음과 같은 오류가 나..

아마도 Registering CNI update handler... 부분에서 오류가 나는 것 같은데 ... register_cni_update_handler 부분에서 문제가 될만한 부분이 있을까?? 

"
//utils/diagnosis.rs
use std::sync::{Arc, Once};
use log::error;
use serde::{Serialize, Deserialize};
use once_cell::sync::OnceCell;

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Usage {
    pub timestamp: String,
    pub cpu_usage: f32,
    pub ram_usage: f32,
    pub storage: StorageInfo,
    pub usb: UsbInfo,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct CpuUsageRecord {
    pub timestamp: u64,
    pub usage: f32,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct UsbInfo {
    pub connected: bool,
    pub total: Option<u64>,
    pub used: Option<u64>,
    pub usage: Option<f32>,
}

#[derive(Debug, Clone,Default,Serialize, Deserialize)]
pub struct StorageInfo {
    pub total: u64,
    pub used: u64,
    pub usage: f32,
}

pub fn get_current_timestamp() -> String {
    let now = chrono::Utc::now();
    now.to_rfc3339()
}

pub mod implement;
// DiagnosisInterface 타입 정의
pub type DiagnosisInterface = implement::DiagnosisImpl;

/// **📌 전역 인스턴스 (`OnceCell<Arc<T>>` 사용)**
static DIAGNOSIS_INSTANCE: OnceCell<Arc<DiagnosisInterface>> = OnceCell::new();
static INIT: Once = Once::new();
/// **📌 DiagnosisInstance 초기화 함수**
pub fn init_diagnosis_instance() {
   INIT.call_once(|| {
       let instance = DiagnosisInterface::new(); // `new()` 호출
       DIAGNOSIS_INSTANCE
           .set(instance)
           .expect("Failed to initialize DiagnosisImpl instance");
   });
}
/// **📌 DiagnosisInstance 가져오기**
pub fn diagnosis_instance() -> Arc<DiagnosisInterface> {
   DIAGNOSIS_INSTANCE.get().expect("Diagnosis instance is not initialized!").clone()
}
"

근데 나는 해당 register_cni_update_handler 함수의 내용을 다른 함수에 있는 부분을 그래도 가져다 쓰고, 값을 저장하는 부분만 우리꺼에 맞춰서 수정한거거든 ..
"
fn main() {
    pretty_env_logger::init();

    let args = Args::parse();
    data_logging::set_logging_path(args.logging_path.as_str());

    #[cfg(feature = "webos")]
    {
        set_application_name("com.b2b.diagnosis.service");
    }

    if let Err(e) = db::init() {
        error!("Failed to initialize db: {e}");
        std::process::exit(1);
    }

    // 기본 진단 항목을 등록합니다.
    // (CPU, 메모리, 저장소, 네트워크)
    system().register().unwrap();

    // 진단이 종료되었음을 알리기 위한 채널을 설정합니다.
    let notify_handle = status().read().get_notify_sender();
    diagnosis_results().set_status_notifier(notify_handle);

    info!("Diagnosis service is starting");
    // let _dbus_server = DbusServerBuilder::default().build().unwrap();
    #[cfg(feature = "linux")]
    let _dbus_server = Runtime::new().unwrap().block_on(async {
        DbusServerBuilder.build().await.unwrap_or_else(|e| {
            error!("Failed to build DbusServer: {e}");
            std::process::exit(1)
        })
    });

    #[cfg(feature = "webos")]
    {
        let handle = get_ls_handle().unwrap();
        let luna_service = luna_service::LunaService::new(handle);
        luna_service.run_background().unwrap();
    }
    info!("Diagnosis service is ready");

    // cpu, usb, ram, disk 사용량을 읽어옵니다.

    // system type facility를 가져옵니다.
    
    let system_facilities_result = data_manager::facility::get_list_by_type(&FacilityType::System);

    //Vec<FacilityInfo> 에서 sytem id를 찾아서 system_facility에 저장합니다.
    // system list 에서 name이 system인걸 찾아서, facility_id를 가져옵니다.
    let system_facilities = match system_facilities_result {
        Ok(facilities) => facilities,
        Err(e) => {
            error!("Failed to get system facilities: {e}");
            std::process::exit(1);
        }
    };
    let system_facility = system_facilities.iter().find(|facility| facility.name == "system");
    

    // // 디버깅을 위해 각 facility 배열 및 id 출력
    info!("system_facility: {system_facility:?}");

    if let Some(facility) = system_facility {
        for (cni, value) in &facility.cnis {
            if let Some(usage_value) = value {
                let usage = match usage_value.parse::<f32>() {
                    Ok(usage) => usage,
                    Err(e) => {
                        warn!("parse {} usage failed: {e:?}", cni);
                        continue;
                    }
                };
    
                match cni.as_str() {
                    "cpu0_usage" => system().add_cpu_usage(0, usage),
                    "cpu1_usage" => system().add_cpu_usage(1, usage),
                    "cpu2_usage" => system().add_cpu_usage(2, usage),
                    "cpu3_usage" => system().add_cpu_usage(3, usage),
                    "ram_usage" => system().add_memory_usage(usage),
                    "disk_usage" => system().add_storage_usage(usage),
                    "usb_usage" => system().add_usb_usage(usage),
                    _ => info!("Unknown cni: {}", cni),
                }
            }
        }
    }

    // 변경 시 처리할 함수를 등록합니다.
    let mut filter = data_manager::facility::watch::FacilityFilter::default();
    filter.facility_type = Some(FacilityType::System);
    if let Err(e) = data_manager::facility::watch::cni_updated(filter, move |value| {
        let cni_updated: CniUpdated = match serde_json::from_str(value) {
            Ok(cni) => cni,
            Err(e) => {
                warn!("parse value updated failed: {e:?}");
                return;
            }
        };

        // cni_updated에서 value를 가져옵니다.
        let usage_value = cni_updated.value.clone(); // value 필드가 CniUpdated 구조체에 있어야 합니다.

        // usage_value를 f32로 파싱합니다.
        let usage = match usage_value.parse::<f32>() {
            Ok(usage) => usage,
            Err(e) => {
                warn!("parse {} usage failed: {e:?}", cni_updated.cni);
                return;
            }
        };
        // 디버깅용 cni_updated 출력
        info!("CNI updated: {cni_updated:?}");
        match cni_updated.cni.as_str() {
            "cpu0_usage" => {
                system().add_cpu_usage(0, usage);
            }
            "cpu1_usage" => {
                system().add_cpu_usage(1, usage);
            }
            "cpu2_usage" => {
                system().add_cpu_usage(2, usage);
            }
            "cpu3_usage" => {
                system().add_cpu_usage(3, usage);
            }
            "ram_usage" => {
                system().add_memory_usage(usage);
            }
            "disk_usage" => {
                system().add_storage_usage(usage);
            }
            "usb_usage" => {
                system().add_usb_usage(usage);
            }
            _ => {
                info!("Unknown cni: {}", cni_updated.cni);
                return;
            }
        }

        debug!("CNI updated: {cni_updated:?}");
    }) {
        error!("Failed to watch controlled point: {e}");
        std::process::exit(1);
    }

    std::thread::park();
}
"
