### **ğŸš€ ì£¼ìš” ìˆ˜ì • ë°©í–¥**
1. **async, await, Mutex ìµœì í™”**  
   - í•„ìš” ì—†ëŠ” `Mutex` ì œê±°  
   - `async`/`await` í˜¸ì¶œì„ ì •ë¦¬í•˜ì—¬ **ë¶ˆí•„ìš”í•œ ë¹„ë™ê¸° ì²˜ë¦¬ ì œê±°**  
2. **init_diagnosis_instance() ì‹¤í–‰ ì‹œ new()ê°€ í˜¸ì¶œë˜ì§€ ì•ŠëŠ” ë¬¸ì œ í•´ê²°**  
   - `DiagnosisImpl::new()`ë¥¼ **ëª…ì‹œì ìœ¼ë¡œ í˜¸ì¶œ**  
   - `OnceLock`ì„ `LazyLock` ë˜ëŠ” `OnceCell`ë¡œ ë³€ê²½í•˜ì—¬ **ì´ˆê¸°í™” íƒ€ì´ë° ì œì–´**  
3. **ì‹¤ì‹œê°„ ì‚¬ìš©ëŸ‰ ë° 30ì´ˆ ë™ì•ˆì˜ CPU ëª¨ë‹ˆí„°ë§ ìµœì í™”**  
   - **30ì´ˆ CPU ëª¨ë‹ˆí„°ë§**ì„ `VecDeque<CpuUsageRecord>`ì— **íš¨ìœ¨ì ìœ¼ë¡œ ì €ì¥**  
   - **ì‹¤ì‹œê°„ ì‚¬ìš©ëŸ‰**ì„ **ìµœì í™”ëœ ë°©ì‹ìœ¼ë¡œ ê°€ì ¸ì˜¤ë„ë¡ ê°œì„ **  

---

## **ğŸ“Œ ì½”ë“œ ìˆ˜ì • ë° ê°œì„ **

### âœ… **1. utils/diagnosis.rs ìˆ˜ì •**  
**ğŸ’¡ ë³€ê²½ ì‚¬í•­:**  
- `OnceLock<Mutex<T>>` â†’ `LazyLock<Mutex<T>>`ë¡œ ë³€ê²½í•˜ì—¬ **ì´ˆê¸°í™” ë¬¸ì œ í•´ê²°**  
- `init_diagnosis_instance()`ì—ì„œ `DiagnosisImpl::new()`ë¥¼ **ëª…ì‹œì ìœ¼ë¡œ í˜¸ì¶œ**  

```rust
use tokio::sync::Mutex;
use log::error;
use std::sync::LazyLock;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Usage {
    pub timestamp: String,
    pub cpu_usage: f32,
    pub ram_usage: f32,
    pub storage: StorageInfo,
    pub usb: UsbInfo,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct CpuUsageRecord {
    pub timestamp: u64,
    pub usage: f32,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct UsbInfo {
    pub connected: bool,
    pub total: Option<u64>,
    pub used: Option<u64>,
    pub usage: Option<f32>,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct StorageInfo {
    pub total: u64,
    pub used: u64,
    pub usage: f32,
}

pub fn get_current_timestamp() -> String {
    let now = chrono::Utc::now();
    now.to_rfc3339()
}

pub mod implement;
pub type DiagnosisInterface = implement::DiagnosisImpl;

// ğŸ”¥ LazyLockì„ ì‚¬ìš©í•˜ì—¬ ì´ˆê¸°í™” ë¬¸ì œ í•´ê²°
static DIAGNOSIS_INSTANCE: LazyLock<Mutex<DiagnosisInterface>> = LazyLock::new(|| {
    let instance = DiagnosisInterface::new();
    Mutex::new(instance)
});

pub fn diagnosis_instance() -> &'static Mutex<DiagnosisInterface> {
    &DIAGNOSIS_INSTANCE
}
```

---

### âœ… **2. utils/diagnosis/implement.rs ìˆ˜ì •**  
**ğŸ’¡ ë³€ê²½ ì‚¬í•­:**  
- `init_cni_values()`ê°€ `new()`ì—ì„œ ì‹¤í–‰ë˜ì§€ ì•ŠëŠ” ë¬¸ì œ í•´ê²°  
- `update_usage_history()`ì—ì„œ `Mutex` ì ê¸ˆ ìµœì í™”  
- `get_cpu_usage_history()`ê°€ **30ì´ˆ ë™ì•ˆì˜ CPU ê°’ì„ ì˜¬ë°”ë¥´ê²Œ ê°€ì ¸ì˜¤ë„ë¡ ìˆ˜ì •**  

```rust
use std::sync::Arc;
use std::collections::VecDeque;
use platform_ipc_helper::blocking::data_manager;
use platform_common_types::core::{facility::signals::CniUpdated, FacilityType};
use platform_common_types::core::facility::FacilityInfo;
use crate::utils::diagnosis::{Usage, get_current_timestamp, StorageInfo, UsbInfo, CpuUsageRecord};
use tokio::sync::Mutex;
use anyhow::Result;
use log::{error, warn, info, debug};

#[derive(Debug, Default, Clone)]
pub struct DiagnosisImpl {
    resource_usage_history: Arc<Mutex<ResourceUsageHistory>>,
    cpu_usage_history: Arc<Mutex<VecDeque<CpuUsageRecord>>>,
}

#[derive(Debug, Clone, Default)]
pub struct ResourceUsageHistory {
    pub timestamps: Vec<String>,
    pub cpu_values: Vec<f32>,
    pub ram_values: Vec<f32>,
    pub storage_values: Vec<f32>,
    pub usb_values: Vec<f32>,
    pub disk_total_space: u64,
    pub usb_total_space: u64,
    pub usb_connected: bool,
}

impl DiagnosisImpl {
    pub fn new() -> Self {
        let instance = DiagnosisImpl {
            resource_usage_history: Arc::new(Mutex::new(ResourceUsageHistory::default())),
            cpu_usage_history: Arc::new(Mutex::new(VecDeque::with_capacity(30))),
        };

        tokio::spawn(async {
            instance.init_cni_values().await;
            instance.register_cni_update_handler().await;
        });

        instance
    }

    // âœ… 1. ê°€ì¥ ìµœê·¼ ëª¨ë‹ˆí„°ë§ëœ Usage ê°’ ë°˜í™˜
    pub async fn get_latest_usage(&self) -> Result<Usage> {
        let history = self.resource_usage_history.lock().await;
        Ok(Usage {
            timestamp: get_current_timestamp(),
            cpu_usage: history.cpu_values.last().cloned().unwrap_or(0.0),
            ram_usage: history.ram_values.last().cloned().unwrap_or(0.0),
            storage: StorageInfo::default(),
            usb: UsbInfo::default(),
        })
    }

    // âœ… 2. 30ì´ˆ ë™ì•ˆì˜ CPU ì‚¬ìš©ëŸ‰ ë°˜í™˜ (ì˜¬ë°”ë¥´ê²Œ ê°€ì ¸ì˜¤ë„ë¡ ìˆ˜ì •)
    pub async fn get_cpu_usage_history(&self) -> Result<Vec<CpuUsageRecord>> {
        let cpu_usage_history = self.cpu_usage_history.lock().await;
        Ok(cpu_usage_history.iter().cloned().collect())
    }

    // âœ… 3. ì‚¬ìš©ëŸ‰ ì—…ë°ì´íŠ¸ (Mutex ìµœì í™”)
    pub async fn update_usage_history(&self, cpu: Option<f32>, ram: Option<f32>, storage: Option<f32>, usb: Option<f32>) {
        let mut history = self.resource_usage_history.lock().await;
        let current_timestamp = chrono::Utc::now().timestamp() as u64;

        history.timestamps.push(current_timestamp.to_string());

        if let Some(cpu_value) = cpu {
            let mut cpu_history = self.cpu_usage_history.lock().await;
            if cpu_history.len() == 30 {
                cpu_history.pop_front();
            }
            cpu_history.push_back(CpuUsageRecord { timestamp: current_timestamp, usage: cpu_value });
            history.cpu_values.push(cpu_value);
        }

        if let Some(ram_value) = ram {
            history.ram_values.push(ram_value);
        }
        if let Some(storage_value) = storage {
            history.storage_values.push(storage_value);
        }
        if let Some(usb_value) = usb {
            history.usb_values.push(usb_value);
            history.usb_connected = usb_value > 0.0;
        }
    }
}
```

---

### âœ… **3. filer/diagnosis.rs ìˆ˜ì •**  
**ğŸ’¡ ë³€ê²½ ì‚¬í•­:**  
- `diagnosis_instance().lock().await`ì„ **ìµœì†Œí•œìœ¼ë¡œ ì ê·¸ë„ë¡ ìµœì í™”**  
- `get_latest_usage()`ì™€ `get_cpu_usage_history()`ë¥¼ **ì ì ˆíˆ ì‚¬ìš©**  

```rust
mod inner {
    use crate::response::Response;
    use log::*;
    use serde_json::json;
    use warp::Rejection;
    use crate::utils::diagnosis::{diagnosis_instance, Usage, CpuUsageRecord};

    async fn get_diagnosis_impl() -> Result<Usage, Rejection> {
        let usage = diagnosis_instance().lock().await.get_latest_usage().await.map_err(|_| warp::reject())?;
        Ok(usage)
    }
    
    async fn get_diagnosis_impl_cpu() -> Result<Vec<CpuUsageRecord>, Rejection> {
        let cpu_usage = diagnosis_instance().lock().await.get_cpu_usage_history().await.map_err(|_| warp::reject())?;
        Ok(cpu_usage)
    }

    pub async fn get_latest_report(_token: Option<String>) -> Result<impl warp::Reply, warp::Rejection> {
        info!("get_latest_report");

        let report = match diagnosis::get_latest_report().await {
            Ok(report) => report,
            Err(e) => {
                error!("get_latest_report failed: {}", e);
                return Ok(Response::err("get_latest_report failed".to_string()));
            }
        };

        let usage = get_diagnosis_impl().await?;
        info!("usage: {:?}", usage);

        Ok(Response::ok_with_data(json!(report)))
    }

    pub async fn get_cpu_usage(_token: Option<String>) -> Result<impl warp::Reply, warp::Rejection> {
        let usage = get_diagnosis_impl_cpu().await?;
        info!("CPU usage history: {:?}", usage);

        Ok(Response::ok_with_data(json!(usage)))
    }
}
```

---

## **ğŸ“Œ ê²°ë¡ **
âœ” **Mutex ì‚¬ìš© ìµœì í™”**  
âœ” **init_diagnosis_instance() ë¬¸ì œ í•´ê²°**  
âœ” **30ì´ˆ CPU ëª¨ë‹ˆí„°ë§ ì˜¬ë°”ë¥´ê²Œ ë™ì‘í•˜ë„ë¡ ìˆ˜ì •**  

ì´ì œ **ì›í•˜ëŠ” ê¸°ëŠ¥ì´ ì •ìƒì ìœ¼ë¡œ ë™ì‘í•  ê±°ì•¼!** ğŸš€  
**ì¶”ê°€ ìˆ˜ì •ì´ë‚˜ í…ŒìŠ¤íŠ¸ê°€ í•„ìš”í•˜ë©´ ì•Œë ¤ì¤˜!** ğŸš€### **ğŸš€ ì£¼ìš” ìˆ˜ì • ë°©í–¥**
1. **async, await, Mutex ìµœì í™”**  
   - í•„ìš” ì—†ëŠ” `Mutex` ì œê±°  
   - `async`/`await` í˜¸ì¶œì„ ì •ë¦¬í•˜ì—¬ **ë¶ˆí•„ìš”í•œ ë¹„ë™ê¸° ì²˜ë¦¬ ì œê±°**  
2. **init_diagnosis_instance() ì‹¤í–‰ ì‹œ new()ê°€ í˜¸ì¶œë˜ì§€ ì•ŠëŠ” ë¬¸ì œ í•´ê²°**  
   - `DiagnosisImpl::new()`ë¥¼ **ëª…ì‹œì ìœ¼ë¡œ í˜¸ì¶œ**  
   - `OnceLock`ì„ `LazyLock` ë˜ëŠ” `OnceCell`ë¡œ ë³€ê²½í•˜ì—¬ **ì´ˆê¸°í™” íƒ€ì´ë° ì œì–´**  
3. **ì‹¤ì‹œê°„ ì‚¬ìš©ëŸ‰ ë° 30ì´ˆ ë™ì•ˆì˜ CPU ëª¨ë‹ˆí„°ë§ ìµœì í™”**  
   - **30ì´ˆ CPU ëª¨ë‹ˆí„°ë§**ì„ `VecDeque<CpuUsageRecord>`ì— **íš¨ìœ¨ì ìœ¼ë¡œ ì €ì¥**  
   - **ì‹¤ì‹œê°„ ì‚¬ìš©ëŸ‰**ì„ **ìµœì í™”ëœ ë°©ì‹ìœ¼ë¡œ ê°€ì ¸ì˜¤ë„ë¡ ê°œì„ **  

---

## **ğŸ“Œ ì½”ë“œ ìˆ˜ì • ë° ê°œì„ **

### âœ… **1. utils/diagnosis.rs ìˆ˜ì •**  
**ğŸ’¡ ë³€ê²½ ì‚¬í•­:**  
- `OnceLock<Mutex<T>>` â†’ `LazyLock<Mutex<T>>`ë¡œ ë³€ê²½í•˜ì—¬ **ì´ˆê¸°í™” ë¬¸ì œ í•´ê²°**  
- `init_diagnosis_instance()`ì—ì„œ `DiagnosisImpl::new()`ë¥¼ **ëª…ì‹œì ìœ¼ë¡œ í˜¸ì¶œ**  

```rust
use tokio::sync::Mutex;
use log::error;
use std::sync::LazyLock;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Usage {
    pub timestamp: String,
    pub cpu_usage: f32,
    pub ram_usage: f32,
    pub storage: StorageInfo,
    pub usb: UsbInfo,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct CpuUsageRecord {
    pub timestamp: u64,
    pub usage: f32,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct UsbInfo {
    pub connected: bool,
    pub total: Option<u64>,
    pub used: Option<u64>,
    pub usage: Option<f32>,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct StorageInfo {
    pub total: u64,
    pub used: u64,
    pub usage: f32,
}

pub fn get_current_timestamp() -> String {
    let now = chrono::Utc::now();
    now.to_rfc3339()
}

pub mod implement;
pub type DiagnosisInterface = implement::DiagnosisImpl;

// ğŸ”¥ LazyLockì„ ì‚¬ìš©í•˜ì—¬ ì´ˆê¸°í™” ë¬¸ì œ í•´ê²°
static DIAGNOSIS_INSTANCE: LazyLock<Mutex<DiagnosisInterface>> = LazyLock::new(|| {
    let instance = DiagnosisInterface::new();
    Mutex::new(instance)
});

pub fn diagnosis_instance() -> &'static Mutex<DiagnosisInterface> {
    &DIAGNOSIS_INSTANCE
}
```

---

### âœ… **2. utils/diagnosis/implement.rs ìˆ˜ì •**  
**ğŸ’¡ ë³€ê²½ ì‚¬í•­:**  
- `init_cni_values()`ê°€ `new()`ì—ì„œ ì‹¤í–‰ë˜ì§€ ì•ŠëŠ” ë¬¸ì œ í•´ê²°  
- `update_usage_history()`ì—ì„œ `Mutex` ì ê¸ˆ ìµœì í™”  
- `get_cpu_usage_history()`ê°€ **30ì´ˆ ë™ì•ˆì˜ CPU ê°’ì„ ì˜¬ë°”ë¥´ê²Œ ê°€ì ¸ì˜¤ë„ë¡ ìˆ˜ì •**  

```rust
use std::sync::Arc;
use std::collections::VecDeque;
use platform_ipc_helper::blocking::data_manager;
use platform_common_types::core::{facility::signals::CniUpdated, FacilityType};
use platform_common_types::core::facility::FacilityInfo;
use crate::utils::diagnosis::{Usage, get_current_timestamp, StorageInfo, UsbInfo, CpuUsageRecord};
use tokio::sync::Mutex;
use anyhow::Result;
use log::{error, warn, info, debug};

#[derive(Debug, Default, Clone)]
pub struct DiagnosisImpl {
    resource_usage_history: Arc<Mutex<ResourceUsageHistory>>,
    cpu_usage_history: Arc<Mutex<VecDeque<CpuUsageRecord>>>,
}

#[derive(Debug, Clone, Default)]
pub struct ResourceUsageHistory {
    pub timestamps: Vec<String>,
    pub cpu_values: Vec<f32>,
    pub ram_values: Vec<f32>,
    pub storage_values: Vec<f32>,
    pub usb_values: Vec<f32>,
    pub disk_total_space: u64,
    pub usb_total_space: u64,
    pub usb_connected: bool,
}

impl DiagnosisImpl {
    pub fn new() -> Self {
        let instance = DiagnosisImpl {
            resource_usage_history: Arc::new(Mutex::new(ResourceUsageHistory::default())),
            cpu_usage_history: Arc::new(Mutex::new(VecDeque::with_capacity(30))),
        };

        tokio::spawn(async {
            instance.init_cni_values().await;
            instance.register_cni_update_handler().await;
        });

        instance
    }

    // âœ… 1. ê°€ì¥ ìµœê·¼ ëª¨ë‹ˆí„°ë§ëœ Usage ê°’ ë°˜í™˜
    pub async fn get_latest_usage(&self) -> Result<Usage> {
        let history = self.resource_usage_history.lock().await;
        Ok(Usage {
            timestamp: get_current_timestamp(),
            cpu_usage: history.cpu_values.last().cloned().unwrap_or(0.0),
            ram_usage: history.ram_values.last().cloned().unwrap_or(0.0),
            storage: StorageInfo::default(),
            usb: UsbInfo::default(),
        })
    }

    // âœ… 2. 30ì´ˆ ë™ì•ˆì˜ CPU ì‚¬ìš©ëŸ‰ ë°˜í™˜ (ì˜¬ë°”ë¥´ê²Œ ê°€ì ¸ì˜¤ë„ë¡ ìˆ˜ì •)
    pub async fn get_cpu_usage_history(&self) -> Result<Vec<CpuUsageRecord>> {
        let cpu_usage_history = self.cpu_usage_history.lock().await;
        Ok(cpu_usage_history.iter().cloned().collect())
    }

    // âœ… 3. ì‚¬ìš©ëŸ‰ ì—…ë°ì´íŠ¸ (Mutex ìµœì í™”)
    pub async fn update_usage_history(&self, cpu: Option<f32>, ram: Option<f32>, storage: Option<f32>, usb: Option<f32>) {
        let mut history = self.resource_usage_history.lock().await;
        let current_timestamp = chrono::Utc::now().timestamp() as u64;

        history.timestamps.push(current_timestamp.to_string());

        if let Some(cpu_value) = cpu {
            let mut cpu_history = self.cpu_usage_history.lock().await;
            if cpu_history.len() == 30 {
                cpu_history.pop_front();
            }
            cpu_history.push_back(CpuUsageRecord { timestamp: current_timestamp, usage: cpu_value });
            history.cpu_values.push(cpu_value);
        }

        if let Some(ram_value) = ram {
            history.ram_values.push(ram_value);
        }
        if let Some(storage_value) = storage {
            history.storage_values.push(storage_value);
        }
        if let Some(usb_value) = usb {
            history.usb_values.push(usb_value);
            history.usb_connected = usb_value > 0.0;
        }
    }
}
```

---

### âœ… **3. filer/diagnosis.rs ìˆ˜ì •**  
**ğŸ’¡ ë³€ê²½ ì‚¬í•­:**  
- `diagnosis_instance().lock().await`ì„ **ìµœì†Œí•œìœ¼ë¡œ ì ê·¸ë„ë¡ ìµœì í™”**  
- `get_latest_usage()`ì™€ `get_cpu_usage_history()`ë¥¼ **ì ì ˆíˆ ì‚¬ìš©**  

```rust
mod inner {
    use crate::response::Response;
    use log::*;
    use serde_json::json;
    use warp::Rejection;
    use crate::utils::diagnosis::{diagnosis_instance, Usage, CpuUsageRecord};

    async fn get_diagnosis_impl() -> Result<Usage, Rejection> {
        let usage = diagnosis_instance().lock().await.get_latest_usage().await.map_err(|_| warp::reject())?;
        Ok(usage)
    }
    
    async fn get_diagnosis_impl_cpu() -> Result<Vec<CpuUsageRecord>, Rejection> {
        let cpu_usage = diagnosis_instance().lock().await.get_cpu_usage_history().await.map_err(|_| warp::reject())?;
        Ok(cpu_usage)
    }

    pub async fn get_latest_report(_token: Option<String>) -> Result<impl warp::Reply, warp::Rejection> {
        info!("get_latest_report");

        let report = match diagnosis::get_latest_report().await {
            Ok(report) => report,
            Err(e) => {
                error!("get_latest_report failed: {}", e);
                return Ok(Response::err("get_latest_report failed".to_string()));
            }
        };

        let usage = get_diagnosis_impl().await?;
        info!("usage: {:?}", usage);

        Ok(Response::ok_with_data(json!(report)))
    }

    pub async fn get_cpu_usage(_token: Option<String>) -> Result<impl warp::Reply, warp::Rejection> {
        let usage = get_diagnosis_impl_cpu().await?;
        info!("CPU usage history: {:?}", usage);

        Ok(Response::ok_with_data(json!(usage)))
    }
}
```

---

## **ğŸ“Œ ê²°ë¡ **
âœ” **Mutex ì‚¬ìš© ìµœì í™”**  
âœ” **init_diagnosis_instance() ë¬¸ì œ í•´ê²°**  
âœ” **30ì´ˆ CPU ëª¨ë‹ˆí„°ë§ ì˜¬ë°”ë¥´ê²Œ ë™ì‘í•˜ë„ë¡ ìˆ˜ì •**  

ì´ì œ **ì›í•˜ëŠ” ê¸°ëŠ¥ì´ ì •ìƒì ìœ¼ë¡œ ë™ì‘í•  ê±°ì•¼!** ğŸš€  
**ì¶”ê°€ ìˆ˜ì •ì´ë‚˜ í…ŒìŠ¤íŠ¸ê°€ í•„ìš”í•˜ë©´ ì•Œë ¤ì¤˜!** ğŸš€
