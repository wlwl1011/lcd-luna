" INFO  rest_server::utils::diagnosis::implement > Registering CNI update handler...                                                                                                     
 DEBUG moonlight::blocking                      > Received watch request to luna service                                                                                                
 DEBUG moonlight::sync                          > Spawning luna service thread                                                                                                          
thread '<unnamed>' panicked at /root/.cargo/registry/src/index.crates.io-6f17d22bba15001f/glib-0.18.5/src/main_context_futures.rs:562:14:                                               
Spawning local futures only allowed on the thread owning the MainContext: BoolError { message: "Failed to acquire ownership of main context, already acquired by another thread", filen}
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace" 

ì‹¤í–‰ì‹œí‚¤ë©´ ë‹¤ìŒê³¼ ê°™ì€ ì˜¤ë¥˜ê°€ ë‚˜..

ì•„ë§ˆë„ Registering CNI update handler... ë¶€ë¶„ì—ì„œ ì˜¤ë¥˜ê°€ ë‚˜ëŠ” ê²ƒ ê°™ì€ë° ... register_cni_update_handler ë¶€ë¶„ì—ì„œ ë¬¸ì œê°€ ë ë§Œí•œ ë¶€ë¶„ì´ ìˆì„ê¹Œ?? 

"
//utils/diagnosis.rs
use std::sync::{Arc, Once};
use log::error;
use serde::{Serialize, Deserialize};
use once_cell::sync::OnceCell;

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Usage {
    pub timestamp: String,
    pub cpu_usage: f32,
    pub ram_usage: f32,
    pub storage: StorageInfo,
    pub usb: UsbInfo,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct CpuUsageRecord {
    pub timestamp: u64,
    pub usage: f32,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct UsbInfo {
    pub connected: bool,
    pub total: Option<u64>,
    pub used: Option<u64>,
    pub usage: Option<f32>,
}

#[derive(Debug, Clone,Default,Serialize, Deserialize)]
pub struct StorageInfo {
    pub total: u64,
    pub used: u64,
    pub usage: f32,
}

pub fn get_current_timestamp() -> String {
    let now = chrono::Utc::now();
    now.to_rfc3339()
}

pub mod implement;
// DiagnosisInterface íƒ€ì… ì •ì˜
pub type DiagnosisInterface = implement::DiagnosisImpl;

/// **ğŸ“Œ ì „ì—­ ì¸ìŠ¤í„´ìŠ¤ (`OnceCell<Arc<T>>` ì‚¬ìš©)**
static DIAGNOSIS_INSTANCE: OnceCell<Arc<DiagnosisInterface>> = OnceCell::new();
static INIT: Once = Once::new();
/// **ğŸ“Œ DiagnosisInstance ì´ˆê¸°í™” í•¨ìˆ˜**
pub fn init_diagnosis_instance() {
   INIT.call_once(|| {
       let instance = DiagnosisInterface::new(); // `new()` í˜¸ì¶œ
       DIAGNOSIS_INSTANCE
           .set(instance)
           .expect("Failed to initialize DiagnosisImpl instance");
   });
}
/// **ğŸ“Œ DiagnosisInstance ê°€ì ¸ì˜¤ê¸°**
pub fn diagnosis_instance() -> Arc<DiagnosisInterface> {
   DIAGNOSIS_INSTANCE.get().expect("Diagnosis instance is not initialized!").clone()
}
"

ê·¼ë° ë‚˜ëŠ” í•´ë‹¹ register_cni_update_handler í•¨ìˆ˜ì˜ ë‚´ìš©ì„ ë‹¤ë¥¸ í•¨ìˆ˜ì— ìˆëŠ” ë¶€ë¶„ì„ ê·¸ë˜ë„ ê°€ì ¸ë‹¤ ì“°ê³ , ê°’ì„ ì €ì¥í•˜ëŠ” ë¶€ë¶„ë§Œ ìš°ë¦¬êº¼ì— ë§ì¶°ì„œ ìˆ˜ì •í•œê±°ê±°ë“  ..
"
fn main() {
    pretty_env_logger::init();

    let args = Args::parse();
    data_logging::set_logging_path(args.logging_path.as_str());

    #[cfg(feature = "webos")]
    {
        set_application_name("com.b2b.diagnosis.service");
    }

    if let Err(e) = db::init() {
        error!("Failed to initialize db: {e}");
        std::process::exit(1);
    }

    // ê¸°ë³¸ ì§„ë‹¨ í•­ëª©ì„ ë“±ë¡í•©ë‹ˆë‹¤.
    // (CPU, ë©”ëª¨ë¦¬, ì €ì¥ì†Œ, ë„¤íŠ¸ì›Œí¬)
    system().register().unwrap();

    // ì§„ë‹¨ì´ ì¢…ë£Œë˜ì—ˆìŒì„ ì•Œë¦¬ê¸° ìœ„í•œ ì±„ë„ì„ ì„¤ì •í•©ë‹ˆë‹¤.
    let notify_handle = status().read().get_notify_sender();
    diagnosis_results().set_status_notifier(notify_handle);

    info!("Diagnosis service is starting");
    // let _dbus_server = DbusServerBuilder::default().build().unwrap();
    #[cfg(feature = "linux")]
    let _dbus_server = Runtime::new().unwrap().block_on(async {
        DbusServerBuilder.build().await.unwrap_or_else(|e| {
            error!("Failed to build DbusServer: {e}");
            std::process::exit(1)
        })
    });

    #[cfg(feature = "webos")]
    {
        let handle = get_ls_handle().unwrap();
        let luna_service = luna_service::LunaService::new(handle);
        luna_service.run_background().unwrap();
    }
    info!("Diagnosis service is ready");

    // cpu, usb, ram, disk ì‚¬ìš©ëŸ‰ì„ ì½ì–´ì˜µë‹ˆë‹¤.

    // system type facilityë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
    
    let system_facilities_result = data_manager::facility::get_list_by_type(&FacilityType::System);

    //Vec<FacilityInfo> ì—ì„œ sytem idë¥¼ ì°¾ì•„ì„œ system_facilityì— ì €ì¥í•©ë‹ˆë‹¤.
    // system list ì—ì„œ nameì´ systemì¸ê±¸ ì°¾ì•„ì„œ, facility_idë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
    let system_facilities = match system_facilities_result {
        Ok(facilities) => facilities,
        Err(e) => {
            error!("Failed to get system facilities: {e}");
            std::process::exit(1);
        }
    };
    let system_facility = system_facilities.iter().find(|facility| facility.name == "system");
    

    // // ë””ë²„ê¹…ì„ ìœ„í•´ ê° facility ë°°ì—´ ë° id ì¶œë ¥
    info!("system_facility: {system_facility:?}");

    if let Some(facility) = system_facility {
        for (cni, value) in &facility.cnis {
            if let Some(usage_value) = value {
                let usage = match usage_value.parse::<f32>() {
                    Ok(usage) => usage,
                    Err(e) => {
                        warn!("parse {} usage failed: {e:?}", cni);
                        continue;
                    }
                };
    
                match cni.as_str() {
                    "cpu0_usage" => system().add_cpu_usage(0, usage),
                    "cpu1_usage" => system().add_cpu_usage(1, usage),
                    "cpu2_usage" => system().add_cpu_usage(2, usage),
                    "cpu3_usage" => system().add_cpu_usage(3, usage),
                    "ram_usage" => system().add_memory_usage(usage),
                    "disk_usage" => system().add_storage_usage(usage),
                    "usb_usage" => system().add_usb_usage(usage),
                    _ => info!("Unknown cni: {}", cni),
                }
            }
        }
    }

    // ë³€ê²½ ì‹œ ì²˜ë¦¬í•  í•¨ìˆ˜ë¥¼ ë“±ë¡í•©ë‹ˆë‹¤.
    let mut filter = data_manager::facility::watch::FacilityFilter::default();
    filter.facility_type = Some(FacilityType::System);
    if let Err(e) = data_manager::facility::watch::cni_updated(filter, move |value| {
        let cni_updated: CniUpdated = match serde_json::from_str(value) {
            Ok(cni) => cni,
            Err(e) => {
                warn!("parse value updated failed: {e:?}");
                return;
            }
        };

        // cni_updatedì—ì„œ valueë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
        let usage_value = cni_updated.value.clone(); // value í•„ë“œê°€ CniUpdated êµ¬ì¡°ì²´ì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤.

        // usage_valueë¥¼ f32ë¡œ íŒŒì‹±í•©ë‹ˆë‹¤.
        let usage = match usage_value.parse::<f32>() {
            Ok(usage) => usage,
            Err(e) => {
                warn!("parse {} usage failed: {e:?}", cni_updated.cni);
                return;
            }
        };
        // ë””ë²„ê¹…ìš© cni_updated ì¶œë ¥
        info!("CNI updated: {cni_updated:?}");
        match cni_updated.cni.as_str() {
            "cpu0_usage" => {
                system().add_cpu_usage(0, usage);
            }
            "cpu1_usage" => {
                system().add_cpu_usage(1, usage);
            }
            "cpu2_usage" => {
                system().add_cpu_usage(2, usage);
            }
            "cpu3_usage" => {
                system().add_cpu_usage(3, usage);
            }
            "ram_usage" => {
                system().add_memory_usage(usage);
            }
            "disk_usage" => {
                system().add_storage_usage(usage);
            }
            "usb_usage" => {
                system().add_usb_usage(usage);
            }
            _ => {
                info!("Unknown cni: {}", cni_updated.cni);
                return;
            }
        }

        debug!("CNI updated: {cni_updated:?}");
    }) {
        error!("Failed to watch controlled point: {e}");
        std::process::exit(1);
    }

    std::thread::park();
}
"
